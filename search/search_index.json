{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#cryosiam-documentation","title":"CryoSiam Documentation","text":"<p>CryoSiam is a self-supervised deep learning framework for cryo-electron tomography (cryo-ET) that enables  denoising, semantic and instance segmentation, and particle identification without requiring ground-truth annotations.</p> <p>Cryo-ET data are often challenging to analyze due to high noise levels and the lack of labeled training data.  CryoSiam addresses these challenges by learning directly from simulated tomograms and predicting on real data.</p> <p>This documentation is intended for both new and experienced users and provides step-by-step guidance on installing  CryoSiam, running its analysis pipelines, and visualizing results.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Provided trained models with self-supervised learning</li> <li>Denoising and segmentation of cryo-ET tomograms  </li> <li>Support for semantic and instance segmentation workflows  </li> <li>Command-line driven and configurable pipelines  </li> <li>Integrated visualization of the outputs through cryosiam-vis  </li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>If you are new to CryoSiam, we recommend starting here:</p> <ul> <li>Installation \u2013 set up CryoSiam and its dependencies  </li> <li>Usage \u2013 run denoising and segmentation workflows  </li> <li>Tutorial \u2013 follow end-to-end examples on real data</li> </ul> <p>For methodological details and validation, see the CryoSiam preprint: CryoSiam: Self-Supervised Learning for Cryo-Electron Tomography</p> <p>Developed by Frosina Stojanovska in the Zaugg Lab at EMBL, in collaboration with the Mahamid Lab and the Kreshuk Lab.</p>"},{"location":"denoising/","title":"Denoising","text":""},{"location":"denoising/#denoising","title":"Denoising","text":"<p>The denoising module reduces noise in cryo-electron tomograms while preserving structural detail. It is typically the first step in a CryoSiam pipeline, preceding semantic segmentation, instance segmentation, or particle identification.</p> <p>For best performance, it is recommended to use WBP-reconstructed tomograms, as the denoising model was trained on simulated WBP data.</p> <p></p> <ul> <li>Left: Raw WBP noisy tomogram</li> <li>Middle: Gaussian filtered tomogram</li> <li>Right: CryoSiam denoised tomogram</li> </ul>"},{"location":"denoising/#trained-model","title":"Trained Model","text":"<p>A pre-trained denoising model is provided and can be downloaded from:</p> <p>CryoSiam denoising model (v1.0)</p>"},{"location":"denoising/#running-denoising","title":"Running denoising","text":"<p>Denoising is performed via the command-line interface using a YAML configuration file:</p> <pre><code>cryosiam denoise_predict --config_file=configs/config_denoising.yaml\n</code></pre> <p>What this command does</p> <ul> <li>Loads the trained denoising model and the input tomogram(s)</li> <li>Applies sliding-window 3D inference (GPU)</li> <li>Writes denoised tomograms to the specified output directory</li> <li>Optionally saves intermediate or raw prediction files</li> </ul> <p>Visualization Denoised outputs can be visualized using CryoSiam-Vis. See the visualization instructions here.</p>"},{"location":"denoising/#example-configuration-file","title":"Example Configuration File","text":"<p> Download example config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/tomograms'\nprediction_folder: '/scratch/stojanov/dataset1/predictions/denoised'\n\ntrained_model: '/scratch/stojanov/trained_models/cryosiam_denoising.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_raw_predictions: False\nscale_prediction: True\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n\nhyper_parameters:\n  batch_size: 3\n</code></pre>"},{"location":"denoising/#config-reference","title":"Config Reference","text":""},{"location":"denoising/#toplevel-keys","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Directory containing input tomograms to denoise <code>prediction_folder</code> <code>str</code> \u2705 Output directory for denoised tomograms <code>trained_model</code> <code>str</code> \u2705 Path to the trained denoising model checkpoint (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>, default: <code>.mrc</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c List of specific filenames to process. Use <code>null</code> to process all files in <code>data_folder</code> <code>save_raw_predictions</code> <code>bool</code> \u274c Save raw prediction files (.h5) in addition to final outputs <code>scale_prediction</code> <code>bool</code> \u274c Rescale output intensities to [0, 1]"},{"location":"denoising/#parameters","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <p>Tips Keep <code>patch_size</code> consistent with the value used during training (e.g. 128\u00b3 for the provided model). Reduce it only if you encounter GPU memory issues.</p>"},{"location":"denoising/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>batch_size</code> <code>int</code> \u274c Number of 3D patches processed per forward pass."},{"location":"denoising/#outputs","title":"Outputs","text":"<p>The denoising step produces:</p> <ul> <li>Denoised tomograms saved to <code>prediction_folder</code> (file extension as implemented).</li> <li>Optional raw prediction files if <code>save_raw_predictions: true</code>.</li> </ul> <p>Output filenames follow the input basenames with appropriate suffixes.</p>"},{"location":"denoising/#troubleshooting","title":"Troubleshooting","text":"Symptom Suggested Fix <code>CUDA out of memory</code> Reduce <code>batch_size</code> and/or <code>patch_size</code>; ensure no other heavy GPU processes are running. No files processed Ensure <code>data_folder</code> exists and <code>test_files</code> is <code>null</code> or matches filenames exactly. Output intensities look off Toggle <code>scale_prediction</code>. Model/shape mismatch Verify <code>in_channels</code> and <code>spatial_dims</code> and the correct <code>.ckpt</code> file are used."},{"location":"denoising/#next-steps","title":"Next Steps","text":"<p>After denoising, continue with:</p> <ul> <li>Semantic segmentation</li> <li>Semantic segmentation training</li> <li>Instance segmentation</li> <li>Particle identification</li> </ul> <p>For an overview of complete pipelines, see the Usage overview.</p>"},{"location":"installation/","title":"CryoSiam installation","text":""},{"location":"installation/#cryosiam-installation-guide","title":"CryoSiam Installation Guide","text":"<p>This guide walks you through installing CryoSiam in a clean and reproducible way using Conda. The recommended setup supports full support of GPU execution via PyTorch.</p> <p>If you are new to Conda or Python environments, don't worry, each step is explained.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or newer</li> <li>Conda (Miniforge or Anaconda)</li> <li>An NVIDIA GPU with CUDA 11.8+ for GPU acceleration</li> </ul>"},{"location":"installation/#step-1-create-the-environment","title":"Step 1: Create the environment","text":"<p>CryoSiam uses a predefined Conda environment to ensure that all dependencies (including PyTorch) are installed with compatible versions.  If you don't have Conda installed, please follow the guide from here.</p> <p>Run the following command to create the environment:</p> <pre><code>conda env create -f https://github.com/frosinastojanovska/cryosiam/blob/main/environment.yml\n</code></pre> <p>Once the environment is created, activate it: </p><pre><code>conda activate cryosiam\n</code></pre><p></p>"},{"location":"installation/#step-2-install-cryosiam","title":"Step 2: Install <code>cryosiam</code>","text":"<p>With the Conda environment activated, clone the CryoSiam repository:</p> <pre><code>git clone https://github.com/frosinastojanovska/cryosiam.git\ncd cryosiam\n</code></pre> <p>Install CryoSiam into the active environment: </p><pre><code>pip install --no-deps .\n</code></pre><p></p> <p>The <code>--no-deps</code> flag ensures that dependencies provided by Conda are used instead of reinstalling them with pip.</p>"},{"location":"installation/#step-3-verify-the-installation","title":"Step 3: Verify the installation","text":"<p>To confirm that CryoSiam was installed correctly, run:</p> <p></p><pre><code>cryosiam --version\n</code></pre> If the command runs without errors, the installation was successful.<p></p> <p>To check that PyTorch is installed correctly and can detect your GPU:</p> <pre><code>import torch\nprint(torch.cuda.is_available())  # Should return True if GPU is available\n</code></pre> <p>This should print <code>True</code> if a compatible GPU is available and the Pytorch for GPU was installed.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>CUDA errors: Make sure your system has the correct NVIDIA drivers and CUDA version.</li> <li>Missing packages: Make sure the Conda environment is activated before installing or running CryoSiam.</li> <li>Dependency conflicts: Always install CryoSiam in a fresh Conda environment.</li> </ul>"},{"location":"installation/#dont-have-conda-installed","title":"Don't Have Conda Installed?","text":"<p>If you do not have Conda yet, we recommend one of the following options.</p>"},{"location":"installation/#option-1-install-miniforge-recommended","title":"Option 1: Install Miniforge (recommended)","text":"<p>Miniforge is a minimal installer for Conda that uses <code>conda-forge</code> by default.</p> <p>Linux / macOS:</p> <pre><code># Download and install Miniforge\nwget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh\nbash Miniforge3-Linux-x86_64.sh\n</code></pre> <p>Windows:</p> <ol> <li> <p>Download the latest installer from:    https://github.com/conda-forge/miniforge/releases</p> </li> <li> <p>Run the <code>.exe</code> installer and follow the setup.</p> </li> </ol>"},{"location":"installation/#option-2-install-anaconda-full-distribution","title":"Option 2: Install Anaconda (full distribution)","text":"<p>Anaconda includes Conda, Python, and hundreds of data scientific packages.</p> <p>Download from: https://www.anaconda.com/products/distribution</p> <p>After installing Miniforge or Anaconda, return to the main Conda installation steps above.</p>"},{"location":"installation/#need-help","title":"Need Help?","text":"<p>If you run into issues, feel free to open an issue on the CryoSiam GitHub repository.</p>"},{"location":"installation_vis/","title":"CryoSiam-Vis installation","text":""},{"location":"installation_vis/#cryosiam-vis-installation-guide","title":"CryoSiam-Vis Installation Guide","text":"<p>This guide explains how to install <code>cryosiam-vis</code>, a lightweight visualization tool for exploring and inspecting predictions generated by CryoSiam.</p> <p>CryoSiam-Vis can be installed independently, but it is typically used alongside CryoSiam.</p>"},{"location":"installation_vis/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.8</li> <li>Conda</li> </ul>"},{"location":"installation_vis/#step-1-create-the-environment","title":"Step 1: Create the Environment","text":"<p>CryoSiam-Vis uses a predefined Conda environment to ensure that all visualization dependencies are installed with compatible versions.</p> <p>Create the environment by running:</p> <pre><code>conda env create -f https://github.com/frosinastojanovska/cryosiam_vis/blob/main/environment.yml\n</code></pre> <p>Activate the environment:</p> <pre><code>conda activate cryosiam_vis\n</code></pre>"},{"location":"installation_vis/#step-2-install-cryosiam_vis","title":"Step 2: Install <code>cryosiam_vis</code>","text":"<p>With the environment activated, clone the CryoSiam-Vis repository:</p> <pre><code>git clone https://github.com/frosinastojanovska/cryosiam_vis.git\ncd cryosiam_vis\n</code></pre> <p>Install CryoSiam-Vis into the active environment:</p> <pre><code>pip install --no-deps .\n</code></pre> <p>The <code>--no-deps</code> flag ensures that dependencies provided by Conda are used instead of reinstalling them with pip.</p>"},{"location":"installation_vis/#step-3-verify-the-installation","title":"Step 3. Verify the installation","text":"<p>To verify that CryoSiam-Vis was installed correctly, run:</p> <pre><code>cryosiam_vis --version\n</code></pre>"},{"location":"installation_vis/#dont-have-conda-installed","title":"Don't Have Conda Installed?","text":"<p>If you do not have Conda installed yet, follow the Conda installation instructions provided in the main CryoSiam installation guide:</p> <p>Conda installation instructions \u2192</p>"},{"location":"installation_vis/#need-help","title":"Need Help?","text":"<p>If you encounter issues or unexpected behavior, please open an issue on the CryoSiam-Vis GitHub repository.</p>"},{"location":"instance/","title":"Instance segmentation","text":""},{"location":"instance/#instance-segmentation","title":"Instance Segmentation","text":"<p>The instance segmentation module in CryoSiam identifies individual macromolecular complexes as distinct, volumetric objects within a tomogram.</p> <p>Unlike semantic segmentation, which labels voxels by class, instance segmentation separates individual particles, even when they belong to the same class or touch each other.</p> <p>Instance segmentation is typically run after lamella prediction to restrict analysis to the sample region and avoid false positives outside the lamella.</p> <p>Recommended pipeline: <code>Denoising \u2192 Lamella Prediction \u2192 Instance Segmentation</code></p>"},{"location":"instance/#overview","title":"Overview","text":"<p>Instance segmentation produces:</p> <ul> <li>Instance masks \u2013 each detected object is labeled with a unique ID</li> <li>Probability maps \u2013 voxel-wise confidence of object presence and boundaries</li> <li>Optional lamella masking \u2013 restricts predictions to valid sample regions</li> </ul> <p>Lamella masking is strongly recommended, as the instance model was trained only on lamella regions.</p>"},{"location":"instance/#example-results","title":"Example results","text":""},{"location":"instance/#input-denoised-tomogram","title":"Input (denoised tomogram)","text":""},{"location":"instance/#lamella-mask-recommended","title":"Lamella mask (recommended)","text":""},{"location":"instance/#instance-segmentation-output","title":"Instance segmentation output","text":""},{"location":"instance/#trained-model","title":"Trained Model","text":"<p>A pre-trained instance segmentation model is available: CryoSiam instance segmentation model (v1.0)</p>"},{"location":"instance/#running-instance-segmentation","title":"Running instance segmentation","text":"<p>Run instance segmentation using a YAML configuration file:</p> <pre><code>cryosiam instance_predict --config_file=configs/config_instance.yaml\n</code></pre> <p>To process a single tomogram only, use:</p> <pre><code>cryosiam instance_predict --config_file=configs/config_instance.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"instance/#visualization","title":"Visualization","text":"<p>Instance masks and probability maps can be visualized using CryoSiam-Vis. See visualization instructions here.</p>"},{"location":"instance/#example-configuration-configsconfig_instanceyaml","title":"Example Configuration (<code>configs/config_instance.yaml</code>)","text":"<p> Download instance config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\nmask_folder: '/scratch/stojanov/dataset1/predictions/lamella'\nprediction_folder: '/scratch/stojanov/dataset1/predictions/instance'\n\ntrained_model: '/scratch/stojanov/trained_models/cryosiam_instance.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_raw_predictions: False\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold_foreground: 0.65\n    boundary_bias: 0.8\n    min_center_distance: 1\n    max_center_distance: 5\n    distance_type: 1   # 0 for using only predicted distances, 1 for using predicted distances + cdist from foreground, 2 for using only cdist\n    postprocessing: False\n\nhyper_parameters:\n  batch_size: 10\n</code></pre>"},{"location":"instance/#config-reference","title":"Config Reference","text":""},{"location":"instance/#toplevel-keys","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Directory containing denoised tomograms <code>mask_folder</code> <code>str</code> \u2705 Directory containing lamella masks (recommended <code>prediction_folder</code> <code>str</code> \u2705 Output directory for instance segmentation results <code>trained_model</code> <code>str</code> \u2705 Path to the instance segmentation model checkpoint (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>, default: <code>.mrc</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c Specific tomograms to process; <code>null</code> processes all files <code>save_internal_files</code> <code>bool</code> \u274c Save intermediate outputs (probability maps)"},{"location":"instance/#parameters","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.threshold_foreground</code> <code>float</code> \u2705 Foreground probability cutoff for seed generation (default <code>0.4</code>). Lower = more sensitive <code>network.boundary_bias</code> <code>float</code> \u274c Bias controlling separation of touching objects; higher values enforce stronger borders <code>network.min_center_distance</code> <code>int</code> \u274c Minimum allowed distance (voxels) between centers (controls splitting) <code>network.max_center_distance</code> <code>int</code> \u274c Maximum allowed distance (voxels) for merging/association <code>network.distance_type</code> <code>int</code> \u274c Distance strategy: <code>0</code> predicted, <code>1</code> predicted+cdist (default), <code>2</code> cdist only <code>network.postprocessing</code> <code>bool</code> \u274c Apply additional connected-component cleanup"},{"location":"instance/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>batch_size</code> <code>int</code> \u274c Number of 3D patches processed per forward pass. <p>Tips Lower <code>threshold_foreground</code> to detect weaker objects; raise it to reduce false positives. Tune <code>boundary_bias</code> and center-distance parameters to better separate touching particles. Balance <code>batch_size</code> and <code>patch_size</code> to fit GPU memory.</p>"},{"location":"instance/#troubleshooting","title":"Troubleshooting","text":"Symptom Suggested Fix CUDA out of memory Reduce <code>batch_size</code> or <code>patch_size</code> Objects outside lamella Ensure lamella prediction was run and <code>mask_folder</code> is set correctly Over-segmentation Increase <code>threshold_foreground</code> or adjust center-distance parameters"},{"location":"instance/#next-steps","title":"Next Steps","text":"<ul> <li>Subtomogram embeddings</li> <li>Particle identification</li> <li>Visualization</li> <li>Usage overview</li> </ul>"},{"location":"particle_identification/","title":"Particle identification","text":""},{"location":"particle_identification/#particle-identification-semantic-candidates-particle-centers","title":"Particle Identification (Semantic Candidates \u2192 Particle Centers)","text":"<p>The Particle Identification module in CryoSiam detects candidate macromolecular complexes and converts them into particle coordinates suitable for downstream workflows (e.g. <code>.csv</code> and <code>.star</code> files).</p> <p>This task is typically used when the goal is to localize particles of given type.</p>"},{"location":"particle_identification/#overview","title":"Overview","text":"<p>Particle identification is performed in two steps:</p> <ol> <li>Semantic prediction of candidate classes    A multi-class semantic segmentation model predicts candidate particle regions.</li> <li>Conversion to particle centers    High-confidence regions are converted into particle coordinates.</li> </ol> <p>Recommended pipeline: <code>Denoising \u2192 Lamella Prediction \u2192 Particle identification \u2192 Particle centers (.star / .csv)</code></p> <p>Important: Always use a lamella mask to restrict predictions to the lamella region. Models were trained only on lamella data and may produce false positives outside this region.</p>"},{"location":"particle_identification/#example-result","title":"Example result","text":"<p>Semantic particle prediction (particle centers): </p>"},{"location":"particle_identification/#trained-models","title":"Trained Models","text":"<p>Pre-trained models are provided for particle identification:</p> <ul> <li> <p>Lamella prediction model: CryoSiam lamella model (v1.0)</p> </li> <li> <p>Particle candidate semantic model: CryoSiam particle identification model (v1.0)</p> </li> </ul> <p>You can also train your own model and then perform prediction with that model. Review the Semantic training for explanation of the model training procedure.</p>"},{"location":"particle_identification/#running-particle-identification","title":"Running particle identification","text":"<p>Particle identification is executed in two stages, using the same configuration file.</p>"},{"location":"particle_identification/#stage-1-semantic-prediction-of-particle-candidates","title":"Stage 1: Semantic prediction of particle candidates","text":"<pre><code>cryosiam semantic_predict --config_file=configs/semantic_particle.yaml\n</code></pre> <p>What this step does</p> <ul> <li>Loads the particle-candidate semantic model</li> <li>Performs sliding-window 3D inference</li> <li>Produces semantic prediction volumes</li> </ul>"},{"location":"particle_identification/#stage-2-convert-semantic-predictions-to-particle-centers","title":"Stage 2: Convert semantic predictions to particle centers","text":"<pre><code>cryosiam semantic_to_centers --config_file=configs/semantic_particle.yaml\n</code></pre> <p>What this step does</p> <ul> <li>Identifies connected high-confidence regions</li> <li>Extracts particle center coordinates</li> <li>Writes particle lists in .csv and .star formats</li> </ul>"},{"location":"particle_identification/#visualization","title":"Visualization","text":"<p>Particle coordinates and semantic predictions can be visualized using CryoSiam-Vis. See visualization instructions here.</p>"},{"location":"particle_identification/#example-configuration-configssemantic_particleyaml","title":"Example Configuration (<code>configs/semantic_particle.yaml</code>)","text":"<pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\nmask_folder: '/scratch/stojanov/dataset1/predictions/lamella'\nprediction_folder: '/scratch/stojanov/dataset1/predictions/semantic_particle'\n\ntrained_model: '/scratch/stojanov/trained_models/cryosiam_semantic_myco_candidates.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    out_channels: 14\n    threshold: 0.7\n    min_voxels: 10\n\nhyper_parameters:\n  batch_size: 2\n</code></pre>"},{"location":"particle_identification/#configuration-reference","title":"Configuration reference","text":""},{"location":"particle_identification/#top-level-keys","title":"Top-level keys","text":"Key Type Must change Description <code>data_folder</code> <code>str</code> \u2705 Directory containing denoised tomograms <code>mask_folder</code> <code>str</code> \u2705 Directory containing lamella masks <code>prediction_folder</code> <code>str</code> \u2705 Output directory for semantic predictions and particle centers <code>trained_model</code> <code>str</code> \u2705 Path to particle-candidate model checkpoint (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c Specific tomograms to process; <code>null</code> processes all"},{"location":"particle_identification/#parameters","title":"<code>parameters</code>","text":"Key Type Must change Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.threshold</code> <code>float</code> \u274c Probability threshold for candidate detection. <code>network.min_voxels</code> <code>int</code> \u274c Minimum connected-component size (voxels) to keep. Default is 100"},{"location":"particle_identification/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change Description <code>batch_size</code> <code>int</code> \u274c Number of 3D patches processed per forward pass"},{"location":"particle_identification/#outputs","title":"Outputs","text":"<ul> <li>Semantic prediction volumes (intermediate)</li> <li>Particle center files in <code>.csv</code> and <code>.star</code> formats</li> </ul> <p>Output filenames follow the input basenames with appropriate suffixes.</p>"},{"location":"particle_identification/#troubleshooting","title":"Troubleshooting","text":"Symptom Suggested Fix Too many false positives Increase <code>threshold</code> or <code>min_voxels</code>; ensure lamella mask is correct No particles detected Lower <code>threshold</code> or verify trained model CUDA out of memory Reduce <code>batch_size</code> or <code>patch size</code>"},{"location":"particle_identification/#next-steps","title":"Next Steps","text":"<ul> <li>Instance segmentation</li> <li>Semantic segmentation training</li> <li>Usage overview</li> </ul>"},{"location":"processing_functions/","title":"Processing functions","text":""},{"location":"processing_functions/#processing-functions","title":"Processing Functions","text":"<p>CryoSiam provides standalone preprocessing utilities to prepare tomograms and label masks for training and downstream workflows. These commands are independent of the main CryoSiam prediction/training modules and are useful when you need to:</p> <ul> <li>Enforce CryoSiam\u2019s expected intensity convention (scaled to [0,1], typically white-on-black)</li> <li>Generate binary or multi-class training masks from particle coordinates</li> <li>Create masks from STA average maps + orientations</li> <li>Combine per-class binary masks into a single multi-class label volume</li> </ul>"},{"location":"processing_functions/#overview","title":"Overview","text":"Command What it does Typical use <code>processing_invert_scale</code> Invert and/or scale tomogram intensities (optionally percentile clip) Prepare external tomograms for training / pretrained weights <code>processing_create_sphere_mask</code> Create binary sphere masks from particle centers Weak labels / simulated labels <code>processing_create_sphere_mask_multiclass</code> Create multi-class sphere masks from class-labeled centers Multi-class weak labels <code>processing_create_binary_map_after_sta</code> Place a thresholded STA map into tomograms using orientations Shape-aware labels from STA <code>processing_create_multiclass_from_binary_masks</code> Merge multiple binary masks into one multi-class mask Combine separate labels into one semantic mask"},{"location":"processing_functions/#processing_invert_scale","title":"<code>processing_invert_scale</code>","text":"<p>Invert and/or scale tomogram intensities.</p>"},{"location":"processing_functions/#when-to-use","title":"When to use","text":"<ul> <li>Your tomograms come from a different pipeline and are not in the expected [0,1] range.</li> <li>You need to enforce white-on-black contrast (high density \u2192 high intensity).</li> <li>You want to clip outliers using percentiles before scaling.</li> </ul>"},{"location":"processing_functions/#command","title":"Command","text":"<pre><code>cryosiam processing_invert_scale --input_path /path/to/tomograms_or_one_tomogram.mrc --output_path /path/to/output_folder_or_output_file.mrc --invert --lower_end_percentage 0.1 --upper_end_percentage 99.9\n</code></pre>"},{"location":"processing_functions/#parameters","title":"Parameters","text":"Argument Type Required Description <code>--input_path</code> <code>str</code> \u2705 Path to an input tomogram file or a folder containing tomograms <code>--output_path</code> <code>str</code> \u2705 Output file path (if input is file) or output folder (if input is folder) <code>--invert</code> <code>flag</code> \u274c If set, invert intensities (contrast inversion) <code>--lower_end_percentage</code> <code>float</code> \u2705 Percentile cutoff for lower-end clipping (e.g. <code>0.1</code>) <code>--upper_end_percentage</code> <code>float</code> \u2705 Percentile cutoff for upper-end clipping (e.g. <code>99.9</code>)"},{"location":"processing_functions/#notes","title":"Notes","text":"<ul> <li>If your data is already white-on-black, omit <code>--invert</code> and use only scaling/clipping.</li> <li>Percentile clipping is recommended for tomograms.</li> </ul>"},{"location":"processing_functions/#processing_create_sphere_mask","title":"<code>processing_create_sphere_mask</code>","text":"<p>Create a binary tomogram mask by placing spheres at particle center coordinates.</p>"},{"location":"processing_functions/#when-to-use_1","title":"When to use","text":"<ul> <li>You want weak labels from coordinate picks (manual / particle identification / external picker).</li> <li>You want to generate synthetic semantic masks (single class) for training.</li> </ul>"},{"location":"processing_functions/#command-all-tomograms-referenced-by-the-coordinates-file","title":"Command (all tomograms referenced by the coordinates file)","text":"<pre><code>cryosiam processing_create_sphere_mask --coordinates_file /path/to/particles.star --sphere_radius 6 --output_dir /path/to/output_masks --tomogram_path /path/to/tomograms\n</code></pre>"},{"location":"processing_functions/#command-process-only-one-tomogram","title":"Command (process only one tomogram)","text":"<pre><code>cryosiam processing_create_sphere_mask --coordinates_file /path/to/particles.csv --sphere_radius 6 --output_dir /path/to/output_masks --tomogram_path /path/to/tomograms --tomo_name TS_01.mrc\n</code></pre>"},{"location":"processing_functions/#parameters_1","title":"Parameters","text":"Argument Type Required Description <code>--coordinates_file</code> <code>str</code> \u2705 STAR or CSV file containing particle centers <code>--sphere_radius</code> <code>int</code> \u2705 Sphere radius in voxels <code>--output_dir</code> <code>str</code> \u2705 Output directory for generated masks <code>--tomogram_path</code> <code>str</code> \u2705 Path to a tomogram folder (preferred) or a single tomogram file used to determine output volume size <code>--tomo_name</code> <code>str</code> \u274c Process only one tomogram (must match <code>rlnMicrographName</code> in STAR or <code>tomo</code> in CSV)"},{"location":"processing_functions/#coordinate-file-formats","title":"Coordinate file formats","text":"<p>STAR file</p> <ul> <li>Must contain headers: <code>rlnCoordinateX</code>, <code>rlnCoordinateY</code>, <code>rlnCoordinateZ</code></li> <li>Tomogram association is typically via <code>rlnMicrographName</code></li> </ul> <p>CSV file</p> <ul> <li>Must contain headers (z, y, x order): <code>centroid-0</code>, <code>centroid-1</code>, <code>centroid-2</code></li> <li>Tomogram association via column <code>tomo</code> (recommended)</li> </ul> <p>Coordinates are expected in voxel space.</p>"},{"location":"processing_functions/#processing_create_sphere_mask_multiclass","title":"<code>processing_create_sphere_mask_multiclass</code>","text":"<p>Create a multi-class mask by placing spheres at centers, using class labels and class-specific radii.</p>"},{"location":"processing_functions/#when-to-use_2","title":"When to use","text":"<ul> <li>You have multiple particle types and want a multi-class semantic training mask.</li> <li>You want different radii per class (to reflect expected particle sizes).</li> </ul>"},{"location":"processing_functions/#command_1","title":"Command","text":"<pre><code>cryosiam processing_create_sphere_mask_multiclass --coordinates_file /path/to/particles_with_classes.star --sphere_radius 5,7,9 --output_dir /path/to/output_masks --tomogram_path /path/to/tomograms\n</code></pre>"},{"location":"processing_functions/#parameters_2","title":"Parameters","text":"Argument Type Required Description <code>--coordinates_file</code> <code>str</code> \u2705 STAR or CSV file containing centers and class labels <code>--sphere_radius</code> <code>str</code> \u2705 Comma-separated radii (N integers) where N = number of classes (e.g. <code>5,7,9</code>) <code>--output_dir</code> <code>str</code> \u2705 Output directory for generated masks <code>--tomogram_path</code> <code>str</code> \u2705 Tomogram folder (preferred) or single tomogram to determine output volume size <code>--tomo_name</code> <code>str</code> \u274c Process only one tomogram"},{"location":"processing_functions/#required-columns","title":"Required columns","text":"<p>STAR file</p> <ul> <li>Coordinates: <code>rlnCoordinateX</code>, <code>rlnCoordinateY</code>, <code>rlnCoordinateZ</code></li> <li>Class: <code>rlnClassNumber</code></li> <li>Class numbering must start at 1 and be sequential.</li> </ul> <p>CSV file</p> <ul> <li>Coordinates: <code>centroid-0</code>, <code>centroid-1</code>, <code>centroid-2</code> (z, y, x)</li> <li>Class: <code>semantic_class</code></li> <li>Class numbering must start at 1 and be sequential.</li> </ul>"},{"location":"processing_functions/#processing_create_binary_map_after_sta","title":"<code>processing_create_binary_map_after_sta</code>","text":"<p>Create a binary tomogram mask by placing a thresholded STA average map into a tomogram using particle orientations.</p>"},{"location":"processing_functions/#when-to-use_3","title":"When to use","text":"<ul> <li>You have a STA pipeline that produced:<ul> <li>a STAR file with orientations, and</li> <li>an average map (subvolume) representing the particle</li> </ul> </li> <li>You want shape-aware labels rather than spheres.</li> </ul>"},{"location":"processing_functions/#command_2","title":"Command","text":"<pre><code>cryosiam processing_create_binary_map_after_sta --star_file /path/to/sta_orientations.star --map_file /path/to/average_map.mrc --map_threshold 0.15 --output_dir /path/to/output_masks --example_tomogram /path/to/example_tomogram.mrc\n</code></pre>"},{"location":"processing_functions/#parameters_3","title":"Parameters","text":"Argument Type Required Description <code>--star_file</code> <code>str</code> \u2705 STAR file with orientations after STA <code>--map_file</code> <code>str</code> \u2705 Map inserted into the tomogram (expected to be a cubic subvolume) <code>--output_dir</code> <code>str</code> \u2705 Output directory for generated masks <code>--map_threshold</code> <code>float</code> \u2705 Threshold used to binarize the inserted map <code>--example_tomogram</code> <code>str</code> \u2705 A reference tomogram used to determine output 3D size <code>--tomo_name</code> <code>str</code> \u274c Process only one tomogram (name must match <code>rlnMicrographName</code>)"},{"location":"processing_functions/#processing_create_multiclass_from_binary_masks","title":"<code>processing_create_multiclass_from_binary_masks</code>","text":"<p>Combine multiple binary masks (one per class) into a single multi-class semantic mask.</p>"},{"location":"processing_functions/#expected-folder-structure","title":"Expected folder structure","text":"<p><code>root_binary_masks_folder</code> must contain one subfolder per class label, each holding binary masks for that label:</p> <pre><code>root_binary_masks_folder/\n\u251c\u2500\u2500 class_1/\n\u2502 \u251c\u2500\u2500 TS_01.mrc\n\u2502 \u2514\u2500\u2500 TS_02.mrc\n\u251c\u2500\u2500 class_2/\n\u2502 \u251c\u2500\u2500 TS_01.mrc\n\u2502 \u2514\u2500\u2500 TS_02.mrc\n\u2514\u2500\u2500 class_3/\n  \u251c\u2500\u2500 TS_01.mrc\n  \u2514\u2500\u2500 TS_02.mrc\n</code></pre>"},{"location":"processing_functions/#command_3","title":"Command","text":"<pre><code>cryosiam processing_create_multiclass_from_binary_masks --root_binary_masks_folder /path/to/root_binary_masks_folder --output_dir /path/to/output_multiclass_masks\n</code></pre>"},{"location":"processing_functions/#parameters_4","title":"Parameters","text":"Argument Type Required Description <code>--root_binary_masks_folder</code> <code>str</code> \u2705 Folder containing per-class subfolders with binary masks <code>--output_dir</code> <code>str</code> \u2705 Output directory for multi-class masks <code>--tomo_name</code> <code>str</code> \u274c Process only one tomogram (include file extension)"},{"location":"processing_functions/#notes-and-best-practices","title":"Notes and best practices","text":"<ul> <li>All coordinates are expected in voxel space.</li> <li>Always visually inspect a few outputs before training.</li> <li>These tools are commonly used in:<ul> <li>Semantic segmentation training (Steps 1\u20133)</li> <li>Particle identification</li> <li>Subtomogram embeddings (center-based inputs)</li> </ul> </li> </ul>"},{"location":"processing_functions/#next-steps","title":"Next steps","text":"<ul> <li>Semantic segmentation training</li> <li>Usage overview</li> </ul>"},{"location":"semantic/","title":"Semantic segmentation","text":""},{"location":"semantic/#semantic-segmentation","title":"Semantic Segmentation","text":"<p>The semantic segmentation module classifies each voxel of a tomogram into biologically meaningful categories, such as membranes, particles, filaments (DNA/RNA), microtubules, or actin.</p> <p>Semantic segmentation in CryoSiam is typically performed inside the lamella only. Therefore, the module also includes lamella prediction as a preparatory step, which is strongly recommended to avoid false positives outside the lamella region (models were not trained on the surrounding noisy volume).</p>"},{"location":"semantic/#overview","title":"Overview","text":"<p>Semantic segmentation in CryoSiam has two distinct capabilities:</p> <ol> <li> <p>Lamella Prediction</p> <ul> <li>Identifies lamella (sample) region</li> <li>Produces binary masks and probability maps</li> <li>Used to restrict downstream analysis</li> </ul> </li> <li> <p>Voxel-wise Semantic Segmentation</p> <ul> <li>Classifies voxels within the lamella into biological classes.</li> <li>Trained to work with denoised tomograms.</li> </ul> </li> <li> <p>Semantic Postprocessing (optional)</p> <ul> <li>Removes small, spurious connected components</li> <li>Applied independently per semantic class</li> </ul> </li> </ol> <p>Recommended pipeline: <code>Denoising \u2192 Lamella Prediction \u2192 Semantic Segmentation \u2192 (Optional Postprocessing)</code></p>"},{"location":"semantic/#example-results","title":"Example Results","text":"<ul> <li>Lamella mask: restricts analysis to lamella regions</li> <li>Semantic segmentation: predicted classes inside lamella</li> </ul>"},{"location":"semantic/#input-denoised-tomogram","title":"Input (denoised tomogram)","text":""},{"location":"semantic/#lamella-prediction","title":"Lamella prediction","text":""},{"location":"semantic/#semantic-segmentation_1","title":"Semantic segmentation","text":""},{"location":"semantic/#trained-models","title":"Trained Models","text":"<p>Pre-trained models are provided for both steps:</p> <ul> <li>Lamella prediction model: CryoSiam lamella model (v1.0)</li> <li>Semantic segmentation model: CryoSiam semantic model (v1.0)</li> </ul> <p>You can also train your own semantic segmentation model and use it for prediction. See Semantic segmentation  training for details.</p>"},{"location":"semantic/#running-semantic-segmentation","title":"Running semantic segmentation","text":"<p>Semantic segmentation is usually run in two stages (optionally three).</p>"},{"location":"semantic/#stage-1-lamella-prediction","title":"Stage 1: Lamella prediction","text":"<p>Run lamella prediction using a YAML configuration file:</p> <pre><code>cryosiam semantic_predict --config_file=configs/config_lamella.yaml\n</code></pre> <p>What it does</p> <ul> <li>Loads the trained lamella model and your denoised tomogram/s</li> <li>Performs sliding-window 3D inference</li> <li>Writes lamella masks and probability maps to disk</li> </ul>"},{"location":"semantic/#stage-2-semantic-segmentation","title":"Stage 2: Semantic segmentation","text":"<p>Run voxel-wise semantic segmentation using the lamella masks from Stage 1:</p> <pre><code>cryosiam semantic_predict --config_file=configs/config_semantic.yaml\n</code></pre> <p>What this step does</p> <ul> <li>Loads the trained semantic segmentation model</li> <li>Uses lamella masks to restrict predictions</li> <li>Writes semantic segmentation outputs to disk</li> </ul>"},{"location":"semantic/#stage-3-semantic-postprocessing-optional","title":"Stage 3: Semantic postprocessing (optional)","text":"<p>This step removes small connected components independently for each semantic class.</p> <pre><code>cryosiam semantic_postprocessing --config_file=configs/config_semantic.yaml\n</code></pre> <p>Optionally process a single tomogram only:</p> <pre><code>cryosiam semantic_postprocessing --config_file=configs/config_semantic.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"semantic/#visualization","title":"Visualization","text":"<p>Results can be visualized using CryoSiam-Vis. See the visualization instructions here.</p>"},{"location":"semantic/#example-configurations","title":"Example Configurations","text":""},{"location":"semantic/#1-lamella-prediction-configsconfig_lamellayaml","title":"1. Lamella Prediction (<code>configs/config_lamella.yaml</code>)","text":"<p>\ud83d\udce5 Download lamella config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\nprediction_folder: '/scratch/stojanov/dataset1/predictions/lamella'\n\ntrained_model: '/scratch/stojanov/trained_models/cryosiam_lamella.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_internal_files: False\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold: 0.9\n    postprocessing: True\n    3d_postprocessing: False\n\nhyper_parameters:\n  batch_size: 2\n</code></pre>"},{"location":"semantic/#configuration-reference","title":"Configuration reference","text":""},{"location":"semantic/#toplevel-keys","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Directory containing denoised tomograms used for lamella prediction <code>prediction_folder</code> <code>str</code> \u2705 Directory where lamella masks and optional intermediates are saved <code>trained_model</code> <code>str</code> \u2705 Path to the lamella prediction model checkpoint (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>, default: <code>.mrc</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c Specific tomograms to process; <code>null</code> processes all files <code>save_internal_files</code> <code>bool</code> \u274c Save intermediate outputs (probability maps)"},{"location":"semantic/#parameters","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.threshold</code> <code>float</code> \u2705 Probability threshold used to binarize the lamella mask. Default to <code>0.9</code> <code>network.postprocessing</code> <code>bool</code> \u274c Apply morphological postprocessing to clean the mask <code>network.3d_postprocessing</code> <code>bool</code> \u274c Apply postprocessing in full 3D (instead of slice-wise) <p>Tips Lower <code>network.threshold</code> (e.g. 0.7) if lamella masks are too restrictive. Keep <code>postprocessing: True</code> for cleaner masks.</p>"},{"location":"semantic/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>batch_size</code> <code>int</code> \u274c Number of 3D patches processed per forward pass"},{"location":"semantic/#2-semantic-segmentation-configsconfig_semanticyaml","title":"2. Semantic Segmentation (<code>configs/config_semantic.yaml</code>)","text":"<p> Download semantic config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\nmask_folder: '/scratch/stojanov/dataset1/predictions/lamella'\nprediction_folder: '/scratch/stojanov/dataset1/predictions/semantic'\n\ntrained_model: '/scratch/stojanov/trained_models/cryosiam_semantic.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold: 0.1\n    postprocessing_sizes: [ -1, 5000, -1, -1, -1 ]\n\nhyper_parameters:\n  batch_size: 2\n</code></pre>"},{"location":"semantic/#configuration-reference_1","title":"Configuration reference","text":""},{"location":"semantic/#toplevel-keys_1","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Directory containing denoised tomograms used for lamella prediction <code>mask_folder</code> <code>str</code> \u2705 Directory containing lamella masks from the lamella prediction step <code>prediction_folder</code> <code>str</code> \u2705 Directory where semantic segmentation outputs are saved <code>trained_model</code> <code>str</code> \u2705 Path to the lamella prediction model checkpoint (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>, default: <code>.mrc</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c Specific tomograms to process; <code>null</code> processes all files <code>save_internal_files</code> <code>bool</code> \u274c Save intermediate outputs (probability maps)"},{"location":"semantic/#parameters_1","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.threshold</code> <code>float</code> \u2705 Probability cutoff to remove very low-confidence predictions. Default <code>0.1</code>. <code>network.postprocessing_sizes</code> <code>list[int]</code> \u2705 Size thresholds for connected components postprocessing. Example: <code>[ -1, 5000, -1, -1, -1 ]</code> keeps only connected components &gt;5000 voxels for label 2 <p>Tips \u2022 Tune <code>postprocessing_sizes</code> depending on dataset type and noise in predictions.</p>"},{"location":"semantic/#hyper_parameters_1","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>batch_size</code> <code>int</code> \u274c Number of 3D patches processed per forward pass."},{"location":"semantic/#outputs","title":"Outputs","text":"<ul> <li>Lamella masks saved to <code>prediction_folder</code> (.h5).</li> <li>Segmentation mask saved to <code>prediction_folder</code> (.h5).</li> <li>Optional intermediate files, depending on configuration.</li> </ul> <p>Output filenames follow the input basenames with appropriate suffixes.</p>"},{"location":"semantic/#troubleshooting","title":"Troubleshooting","text":"Symptom Suggested Fix False positives outside lamella Ensure lamella prediction was run and <code>mask_folder</code> is set correctly CUDA OOM Reduce <code>batch_size</code> or <code>patch size</code> Blank segmentation Verify model path and reduce thresholds"},{"location":"semantic/#next-steps","title":"Next Steps","text":"<ul> <li>Semantic segmentation training</li> <li>Instance segmentation</li> <li>Particle identification</li> <li>Usage overview</li> </ul>"},{"location":"semantic_training/","title":"Semantic segmentation training","text":""},{"location":"semantic_training/#semantic-segmentation-training","title":"Semantic Segmentation Training","text":"<p>This page explains how to train CryoSiam\u2019s semantic segmentation model using your own annotated (or simulated) cryo-ET tomograms. Training can start from pretrained weights (or from scratch) and supports large-scale, multi-GPU training with extensive data augmentation.</p> <p>Semantic segmentation training in CryoSiam follows a five-step CLI workflow:</p> <ol> <li>Ground-truth filtering (optional)</li> <li>Normalize / scale input tomograms (optional, but strongly recommended for tomograms which are not denoised with    CryoSiam)</li> <li>Preprocess - generate distance maps</li> <li>Patch creation</li> <li>Model training</li> </ol> <p>Each step is executed explicitly to give full control and reproducibility. Example configuration file is given below.</p>"},{"location":"semantic_training/#pretrained-weights","title":"Pretrained weights","text":"<p>To fine-tune instead of training from scratch, download the pretrained checkpoint:</p> <ul> <li>CryoSiam DenseSimSiam pretrained checkpoint (v1.0)</li> </ul> <p>Set it in your config under <code>pretrained_model</code>.</p>"},{"location":"semantic_training/#training-workflow-overview","title":"Training workflow overview","text":""},{"location":"semantic_training/#step-1-filter-ground-truth-labels-optional","title":"Step 1: Filter ground-truth labels (optional)","text":"<p>This step optionally filters and remaps existing semantic label volumes to create a new set of training masks.</p> <p>It is designed for cases where:</p> <ul> <li>Only a subset of classes should be used for training (e.g. simulated datasets with many labeled structures)</li> <li>Binary masks are needed instead of full multi-class labels</li> <li>Existing labels need to be cleaned and validated before training</li> </ul>"},{"location":"semantic_training/#what-this-step-does","title":"What this step does","text":"<p>Given a folder of existing semantic label volumes, CryoSiam can:</p> <ul> <li>Select one label value or multiple label values</li> <li>Create new masks containing only the selected class(es)</li> </ul> <p>If a single label value is selected, the output is a binary foreground mask. If multiple label values are selected, the output contains only those classes.</p> <p>This step does not modify the original labels. Filtered masks are written to a new output folder.</p>"},{"location":"semantic_training/#configuration-options","title":"Configuration options","text":"<ul> <li><code>labels_folder_for_filtering</code> \u2013 path to the folder containing existing semantic label volumes</li> <li><code>selected_labels</code> \u2013 a single label value or a list of label values to keep</li> </ul>"},{"location":"semantic_training/#command","title":"Command","text":"<pre><code>cryosiam semantic_filter_ground_truth --config_file=configs/semantic_training.yaml\n</code></pre> <p>Produces</p> <ul> <li>cleaned / filtered semantic label volumes</li> </ul>"},{"location":"semantic_training/#creating-label-masks-when-none-are-provided","title":"Creating label masks when none are provided","text":"<p>If ground-truth semantic labels are not available, CryoSiam provides preprocessing utilities to generate training masks automatically from given coordinates and/or RELION type orientation angles.</p> <p>These processing functions allow you to:</p> <ul> <li>Create spherical masks from particle center coordinates</li> <li>Generate masks directly from density maps or probability maps</li> </ul> <p>Note: Mask generation is handled by dedicated preprocessing tools and is not part of the semantic training pipeline itself .</p> <p>For details, refer to Processing functions.</p>"},{"location":"semantic_training/#step-2-normalize-and-scale-input-tomograms-optional","title":"Step 2: Normalize and scale input tomograms (optional)","text":"<p>This step ensures that intensities of the input tomograms are scaled and oriented consistently with the expectations of the pretrained semantic segmentation model.</p> <p>The model expects tomograms to be:</p> <ul> <li>Scaled to the range [0, 1]</li> <li>White on black (high density = high intensity)</li> </ul> <p>Correct intensity scaling is critical for stable training and convergence.</p>"},{"location":"semantic_training/#when-is-this-step-required","title":"When is this step required?","text":"<ul> <li>Required if your input tomograms were generated externally or come from a different preprocessing pipeline.</li> <li>If your data is already white-on-black, you can omit <code>--invert</code> and only apply scaling.</li> <li>Can be skipped if you use CryoSiam denoised tomograms and denoising was run with <code>scale_prediction: True</code>.</li> </ul>"},{"location":"semantic_training/#what-this-step-does_1","title":"What this step does","text":"<p>When required, this step:</p> <ul> <li>(Optionally) <code>inverts</code> intensities to enforce white-on-black contrast</li> <li>Rescales tomograms to the range <code>[0, 1]</code></li> <li>Clips extreme intensity values using percentile thresholds <code>[0.1, 99.9]</code></li> </ul>"},{"location":"semantic_training/#command_1","title":"Command","text":"<pre><code>cryosiam processing_invert_scale \\\n --input_path=folder \\\n --output_path=out_folder \\\n --invert \\\n --lower_end_percentage 0.1 \\\n --upper_end_percentage 99.9\n</code></pre> <p>For a detailed explanation of this function and its parameters, refer to Processing functions.</p>"},{"location":"semantic_training/#step-3-generate-distance-maps-for-training","title":"Step 3: Generate distance maps for training","text":"<p>This step generates distance maps from the provided semantic segmentation masks. These distance maps are used as auxiliary training targets by CryoSiam\u2019s semantic segmentation model.</p> <p>This step does not modify, validate, or align the semantic labels. It strictly computes distance-based targets derived from the existing masks.</p> <p>Note: the CLI command name includes \u201cpreprocess\u201d, but in this workflow it is used only for distance-map creation.</p>"},{"location":"semantic_training/#command_2","title":"Command","text":"<pre><code>cryosiam semantic_train_preprocess --config_file=configs/semantic_training.yaml\n</code></pre> <p>Outputs</p> <ul> <li>distance map volumes corresponding to the semantic label masks</li> </ul> <p>These outputs are consumed by the patch creation step and used during training as auxiliary targets</p>"},{"location":"semantic_training/#step-4-create-training-patches","title":"Step 4: Create training patches","text":"<p>This step splits full tomograms and their corresponding training targets into overlapping 3D patches suitable for GPU-based training. Patch creation is required because tomograms are big 3D volumes that can't fit into GPU-memory.</p>"},{"location":"semantic_training/#what-this-step-does_2","title":"What this step does","text":"<p>Given:</p> <ul> <li>Input tomograms (scaled as required in Step 2)</li> <li>Semantic segmentation masks</li> <li>Distance maps generated in Step 3</li> </ul> <p>CryoSiam:</p> <ul> <li>Extracts overlapping 3D patches from tomograms</li> <li>Extracts the corresponding label patches</li> <li>Extracts distance-map patches</li> <li>Optionally discards patches containing only background labels</li> <li>Stores all patches on disk for efficient training</li> </ul> <p>No data augmentation is applied at this stage.</p>"},{"location":"semantic_training/#configuration-options_1","title":"Configuration options","text":"<ul> <li><code>parameters.data.patch_size</code> - size of the 3D training patches.</li> <li><code>parameters.data.patch_overlap</code> - fractional overlap between adjacent patches.</li> <li><code>parameters.data.remove_only_background</code> - if <code>True</code>, patches containing only background labels are discarded.</li> </ul>"},{"location":"semantic_training/#command_3","title":"Command:","text":"<pre><code>cryosiam semantic_train_create_patches --config_file=configs/semantic_training.yaml\n</code></pre> <p>Outputs</p> <ul> <li>Tomogram patches</li> <li>Semantic label patches</li> <li>Distance-map patches</li> </ul>"},{"location":"semantic_training/#step-5-train-the-semantic-segmentation-model","title":"Step 5. Train the semantic segmentation model","text":"<p>This step runs the full semantic segmentation training pipeline using PyTorch Lightning. Training is performed on the patches generated in Step 4 and optionally initialized from pretrained weights.</p>"},{"location":"semantic_training/#what-this-step-does_3","title":"What this step does","text":"<p>During training, CryoSiam:</p> <ul> <li>Loads tomogram, label, and distance-map patches</li> <li>Applies data augmentation on-the-fly</li> <li>Optimizes the semantic segmentation network</li> <li>Optionally predicts auxiliary distance maps (if enabled)</li> <li>Periodically evaluates the model on validation data</li> <li>Saves checkpoints, logs, and training statistics</li> </ul> <p>Training supports single-GPU, multi-GPU, and multi-node execution.</p>"},{"location":"semantic_training/#command_4","title":"Command","text":"<pre><code>cryosiam semantic_train --config_file=configs/semantic_training.yaml\n</code></pre>"},{"location":"semantic_training/#training-on-slurm-clusters","title":"Training on Slurm clusters","text":"<p>When running on a Slurm-managed system, use:</p> <pre><code>srun cryosiam semantic_train --config_file=configs/semantic_training.yaml\n</code></pre> <p>Ensure that Slurm resource requests (GPUs, nodes, CPUs) match the configuration parameters.</p>"},{"location":"semantic_training/#outputs","title":"Outputs","text":"<p>Training produces:</p> <ul> <li>Model checkpoints (<code>.ckpt</code>)</li> <li>Training and validation logs</li> <li>TensorBoard files</li> </ul>"},{"location":"semantic_training/#resuming-and-fine-tuning","title":"Resuming and fine-tuning","text":"<p>To resume interrupted training, set:</p> <pre><code>continue_training: True\n</code></pre> <p>To fine-tune from pretrained weights, set:</p> <pre><code>pretrained_model: /path/to/model.ckpt\ncontinue_training: False\n</code></pre>"},{"location":"semantic_training/#example-configuration-semantic_trainyaml","title":"Example Configuration (semantic_train.yaml)","text":"<p> Download example config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\nlabels_folder: '/scratch/stojanov/dataset1/semantic_gt_for_training'\nnoisy_data_folder: null\npatches_folder: '/scratch/stojanov/dataset1/models/dense_simsiam_semantic_complexes/patches'\ntemp_dir: '/scratch/stojanov/dataset1/models/dense_simsiam_semantic_complexes'\nlog_dir: '/scratch/stojanov/dataset1/models/dense_simsiam_semantic_complexes'\nprediction_folder: '/scratch/stojanov/dataset1/models/dense_simsiam_semantic_complexes/predictions'\npretrained_model: '/scratch/stojanov/trained_models/dense_simsiam_pretrained.ckpt'\nfile_extension: '.mrc'\n\ntrain_files: [ 'sample_1.mrc', 'sample_2.mrc', 'sample_3.mrc', 'sample_4.mrc', 'sample_5.mrc',\n               'sample_6.mrc', 'sample_7.mrc', 'sample_8.mrc', 'sample_9.mrc', 'sample_10.mrc',\n               'sample_11.mrc', 'sample_12.mrc', 'sample_13.mrc', 'sample_14.mrc', 'sample_15.mrc',\n               'sample_16.mrc', 'sample_17.mrc', 'sample_18.mrc', 'sample_19.mrc', 'sample_20.mrc',\n               'sample_21.mrc', 'sample_22.mrc', 'sample_23.mrc', 'sample_24.mrc', 'sample_25.mrc',\n               'sample_26.mrc', 'sample_27.mrc', 'sample_28.mrc', 'sample_29.mrc', 'sample_30.mrc' ]\n\nval_files: null\nvalidation_ratio: 0.1\n\ncontinue_training: False\n\nlabels_folder_for_filtering: null\nselected_labels: null\n\nparameters:\n  nodes: 1\n  gpu_devices: 8\n  data:\n    patch_size: [ 128, 128, 128 ]\n    patch_overlap: 0.5\n    remove_only_background: False\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  transforms:\n    low_pass_sigma_range: [ 0.1, 0.6 ]\n    high_pass_sigma_range: [ 0.1, 0.2 ]\n    high_pass_sigma2_range: [ 4, 6 ]\n    noise_sigma_range: [ 0.01, 0.05 ]\n    combine_transforms: False\n    use_noisy_input: False\n    scale_intensity_factors: null\n    elastic: null\n    zoom: [ 0.8, 1.2 ]\n    rotate: [ 3.14, 3.14, 3.14 ]\n    flip: True\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    out_channels: 7\n    dense_dim: 64\n    filters: [ 32, 64 ]\n    kernel_size: 3\n    padding: 1\n    distance_prediction: True\n    use_dice_loss: True\n    unfreeze_decoder: True\n    unfreeze_backbone: True\n\nhyper_parameters:\n  cache_rate: 0\n  val_interval: 1\n  batch_size: 3\n  optimizer: 'adamw' # one of 'sgd', 'adam', 'adamw'\n  lr: 0.001\n  momentum: 0.9\n  weight_decay: 0.00001\n  max_epochs: 200\n</code></pre>"},{"location":"semantic_training/#config-reference","title":"Config Reference","text":""},{"location":"semantic_training/#toplevel-keys","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Tomograms or precomputed predictions used as input <code>labels_folder</code> <code>str</code> \u2705 Ground-truth semantic labels <code>labels_folder_for_filtering</code> <code>str</code> or <code>null</code> \u274c Optional: folder of label masks to filter/remap in Step 1 <code>selected_labels</code> <code>int</code> / <code>list[int]</code> / <code>null</code> \u274c Optional: label(s) to keep in Step 1 (single value \u2192 binary mask; list \u2192 keep subset) <code>noisy_data_folder</code> <code>str</code> or <code>null</code> \u274c Optional additional input folder (used only if your transforms/pipeline uses noisy input) <code>patches_folder</code> <code>str</code> \u2705 Output folder where training patches will be written (Step 4) <code>temp_dir</code> <code>str</code> \u274c Temporary folder for intermediate files <code>log_dir</code> <code>str</code> \u274c Training logs, checkpoints, TensorBoard output <code>prediction_folder</code> <code>str</code> \u274c Optional folder for prediction sanity checks (if your pipeline writes them) <code>pretrained_model</code> <code>str</code> \u274c Checkpoint to initialize weights (fine-tuning) (<code>.ckpt</code>) <code>file_extension</code> <code>str</code> \u274c Input tomogram extension (<code>.mrc</code> or <code>.rec</code>) <code>train_files</code> <code>list[str]</code> or <code>null</code> \u2705/\u274c Explicit training file list; null uses all files in data_folder (except those assigned to val/test if applicable) <code>val_files</code> <code>list[str]</code> or <code>null</code> \u274c Optional explicit validation list <code>validation_ratio</code> <code>float</code> \u274c Used only if <code>val_files: null</code> (fraction of training set used for validation) <code>continue_training</code> <code>bool</code> \u274c If true, <code>resume</code> training from latest checkpoint under <code>log_dir</code>"},{"location":"semantic_training/#parameters","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>nodes</code> <code>int</code> \u2705 Number of compute nodes for distributed training <code>gpu_devices</code> <code>int</code> or <code>list[int]</code> \u2705 Number of GPUs or GPU indices to use <code>data.patch_size</code> <code>list[int]</code> \u2705 3D patch size used for patch creation + training <code>data.patch_overlap</code> <code>float</code> \u2705 Overlap fraction between patches (e.g. <code>0.5</code>) <code>data.remove_only_background</code> <code>bool</code> \u2705 If <code>true</code>, discard patches containing only background labels <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>transforms.low_pass_sigma_range</code> <code>list[float]</code> \u274c Range for Gaussian low-pass filtering <code>transforms.high_pass_sigma_range</code> <code>list[float]</code> \u274c Range for high-pass filtering (sigma 1) <code>transforms.high_pass_sigma2_range</code> <code>list[float]</code> \u274c Range for high-pass filtering (sigma 2) <code>transforms.noise_sigma_range</code> <code>list[float]</code> \u274c Additive noise range <code>transforms.combine_transforms</code> <code>bool</code> \u274c Combine the blur, high pass and noise transforms in one pass <code>transforms.use_noisy_input</code> <code>bool</code> \u274c If <code>true</code>, uses <code>noisy_data_folder</code> as transformation with input noisy <code>transforms.scale_intensity_factors</code> <code>list[float]</code> \u274c Random intensity scaling factors <code>transforms.elastic</code> <code>list[float]</code> \u274c Elastic deformation magnitude range <code>transforms.zoom</code> <code>list[float]</code> \u274c Zoom range <code>transforms.rotate</code> <code>float</code> \u274c Rotation range (radians) <code>transforms.flip</code> <code>bool</code> \u274c Random flips <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.out_channels</code> <code>int</code> \u274c Number of semantic classes <code>network.dense_dim</code> <code>int</code> \u274c Dense feature dimension (architecture-specific) <code>network.filters</code> <code>list[int]</code> \u274c Convolution filter sizes <code>network.kernel_size</code> <code>int</code> \u274c Convolution kernel size <code>network.padding</code> <code>int</code> \u274c Convolution padding <code>network.distance_prediction</code> <code>bool</code> \u274c If <code>false</code>, the training ignores the distance map loss when training (from distance maps from Step 3) <code>network.use_dice_loss</code> <code>bool</code> \u274c Use Dice loss in addition to standard cross-entropy loss <code>network.unfreeze_decoder</code> <code>bool</code> \u2705 Fine-tuning: unfreeze decoder layers <code>network.unfreeze_backbone</code> <code>bool</code> \u2705 Fine-tuning: unfreeze backbone/encoder layers"},{"location":"semantic_training/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>cache_rate</code> <code>float</code> \u274c Dataset cache rate (<code>0</code> = no caching) <code>val_interval</code> <code>int</code> \u274c Validate every N epochs <code>batch_size</code> <code>int</code> \u2705 Number of patches per batch (default <code>10</code>). <code>optimizer</code> <code>str</code> \u274c Type of optimizer; <code>'sgd'</code>, <code>'adam'</code>, or <code>'adamw'</code> <code>lr</code> <code>float</code> \u274c Learning rate <code>momentum</code> <code>float</code> \u274c Optimizer momentum (used for SGD/Adam variants where applicable) <code>weight_decay</code> <code>float</code> \u274c Weight decay <code>max_epochs</code> <code>int</code> \u274c Number of training epochs"},{"location":"semantic_training/#next-steps","title":"Next Steps","text":"<p>After training, continue with:</p> <ul> <li>Semantic segmentation</li> <li>Particle identification</li> </ul> <p>For an overview of complete pipelines, see the Usage overview.</p>"},{"location":"slurm_parallel/","title":"Scaling to large datasets on HPC","text":""},{"location":"slurm_parallel/#parallel-inference-on-slurm-clusters","title":"Parallel Inference on Slurm Clusters","text":"<p>CryoSiam inference commands (e.g. denoising, semantic segmentation, instance segmentation, embeddings) are executed on a single GPU per command-line call.</p> <p>When processing many tomograms, the recommended way to scale inference on HPC systems is to parallelize over tomograms, running one tomogram per Slurm job.</p> <p>This page explains how to do this safely and efficiently using Slurm job arrays or batched submissions.</p>"},{"location":"slurm_parallel/#key-idea","title":"Key idea","text":"<ul> <li>Each CryoSiam inference command uses 1 GPU</li> <li>Parallelism is achieved by:</li> <li>Splitting tomograms by filename</li> <li>Submitting one Slurm job per tomogram</li> <li>The <code>--filename</code> argument is used to restrict each job to a single tomogram</li> </ul> <p>This approach avoids GPU contention and scales linearly with the number of available GPUs.</p>"},{"location":"slurm_parallel/#typical-use-cases","title":"Typical use cases","text":"<ul> <li>Denoising a large dataset</li> <li>Semantic segmentation over many tomograms</li> <li>Instance segmentation at scale</li> <li>Subtomogram embeddings generation</li> </ul>"},{"location":"slurm_parallel/#step-1-prepare-a-submission-script","title":"Step 1: Prepare a submission script","text":"<p>Below is an example Slurm submission script that runs instance segmentation on a single tomogram passed as a command-line argument.</p> <p>Save this as <code>run_instance_predict.sbatch</code>:</p> <pre><code>#!/bin/bash\n#SBATCH --nodes=1\n#SBATCH --ntasks=16\n#SBATCH --mem=50G\n#SBATCH --time=1-00:00:00\n#SBATCH --gres=gpu:1\n#SBATCH --job-name=\"cryosiam_instance_predict\"\n#SBATCH -o /scratch/dataset/slurm.%N.%j.out\n#SBATCH -e /scratch/dataset/slurm.%N.%j.err\n\necho \"Starting CryoSiam instance prediction\"\necho \"Tomogram: $1\"\n\ncd /scratch/dataset/scripts\nconda activate cryosiam\n\ncryosiam instance_predict \\\n  --config_file=config_dense_simsiam_instance.yaml \\\n  --filename=$1\n\necho \"Done.\"\n</code></pre>"},{"location":"slurm_parallel/#step-2-submit-jobs-for-all-tomograms-in-a-folder","title":"Step 2: Submit jobs for all tomograms in a folder","text":"<p>Assuming all tomograms are located in:</p> <pre><code>/scratch/dataset/data/\n</code></pre> <p>and have extension <code>.mrc</code>, you can submit one job per tomogram using:</p> <pre><code>for f in /scratch/dataset/data/*.mrc; do\n    fname=$(basename \"$f\")\n    sbatch run_instance_predict.sbatch \"$fname\"\ndone\n</code></pre>"},{"location":"slurm_parallel/#job-arrays-recommended-for-large-datasets","title":"Job arrays (recommended for large datasets)","text":"<p>If you have hundreds to thousands of tomograms, a Slurm job array is often cleaner than submitting many individual jobs.</p> <p>The idea is:</p> <ol> <li>Create a text file containing one filename per line (e.g. <code>tomograms.txt</code>)</li> <li>Submit an array job where each task processes one line from that file</li> <li>Use <code>--array=0-(N-1)</code> to match the number of tomograms</li> </ol>"},{"location":"slurm_parallel/#step-1-create-a-file-list-tomogramstxt","title":"Step 1: Create a file list (<code>tomograms.txt</code>)","text":"<p>From a folder containing <code>.mrc</code> tomograms:</p> <pre><code>ls -1 /scratch/dataset/data/*.mrc | xargs -n 1 basename &gt; tomograms.txt\n</code></pre> <p>This produces a plain text file like:</p> <pre><code>TS_01.mrc\nTS_02.mrc\nTS_03.mrc\n...\n</code></pre>"},{"location":"slurm_parallel/#step-2-array-sbatch-script","title":"Step 2: Array sbatch script","text":"<p>Save this as <code>run_instance_predict_array.sbatch</code>:</p> <pre><code>#!/bin/bash\n#SBATCH --nodes=1\n#SBATCH --ntasks=16\n#SBATCH --mem=50G\n#SBATCH --time=1-00:00:00\n#SBATCH --gres=gpu:1\n#SBATCH --job-name=\"cryosiam_instance_predict\"\n#SBATCH -o /scratch/dataset/slurm.%A_%a.out\n#SBATCH -e /scratch/dataset/slurm.%A_%a.err\n#SBATCH --array=0-99\n\nset -euo pipefail\n\nLIST_FILE=/scratch/dataset/scripts/tomograms.txt\nTOMO=$(sed -n \"$((SLURM_ARRAY_TASK_ID+1))p\" \"$LIST_FILE\")\n\necho \"Array task: $SLURM_ARRAY_TASK_ID\"\necho \"Tomogram: $TOMO\"\n\ncd /scratch/dataset/scripts\nconda activate cryosiam\n\ncryosiam instance_predict \\\n  --config_file=config_dense_simsiam_instance.yaml \\\n  --filename=\"$TOMO\"\n\necho \"Done.\"\n</code></pre> <p>Important: replace <code>--array=0-99</code> with the correct range for your dataset. For example, if <code>tomograms.txt</code> has 237 lines, use <code>--array=0-236</code>.</p>"},{"location":"slurm_parallel/#step-3-submit-the-array-job","title":"Step 3: Submit the array job","text":"<pre><code># Count tomograms\nN=$(wc -l &lt; tomograms.txt)\n\n# Submit array using 0..N-1\nsbatch --array=0-$((N-1)) run_instance_predict_array.sbatch\n</code></pre>"},{"location":"slurm_parallel/#optional-limit-the-number-of-concurrent-gpus","title":"(Optional) Limit the number of concurrent GPUs","text":"<p>Many clusters allow a concurrency cap:</p> <pre><code>sbatch --array=0-$((N-1))%20 run_instance_predict_array.sbatch\n</code></pre> <p>This example runs at most 20 jobs at once, preventing overwhelming the scheduler or filesystem.</p>"},{"location":"slurm_parallel/#adapting-job-arrays-to-other-modules","title":"Adapting job arrays to other modules","text":"<p>Replace the command in the script with the module you need, for example:</p> <ul> <li>Denoising:   <pre><code>cryosiam denoise_predict --config_file=config_denoising.yaml --filename=\"$TOMO\"\n</code></pre></li> <li>Semantic segmentation:   <pre><code>cryosiam semantic_predict --config_file=config_semantic.yaml --filename=\"$TOMO\"\n</code></pre></li> <li>Embeddings (per tomogram):   <pre><code>cryosiam simsiam_embeddings_predict --config_file=config_subtomo_embeddings.yaml --filename=\"$TOMO\"\n</code></pre></li> </ul>"},{"location":"slurm_parallel/#best-practices","title":"Best practices","text":"<ul> <li>Use one GPU per job</li> <li>Avoid running multiple CryoSiam jobs on the same GPU</li> <li>Monitor jobs with <code>squeue -u $USER</code></li> <li>Adjust memory and time requests depending on tomogram size</li> </ul>"},{"location":"slurm_parallel/#see-also","title":"See also","text":"<ul> <li>Usage overview</li> </ul>"},{"location":"subtomogram_embeddings/","title":"Subtomogram embeddings","text":""},{"location":"subtomogram_embeddings/#subtomogram-embeddings-generation","title":"Subtomogram Embeddings Generation","text":"<p>The subtomogram embeddings module extracts fixed-length feature representations from segmented subtomograms. These embeddings capture the 3D structural and textural properties of individual macromolecular complexes and enable unsupervised comparison, visualization, and clustering.</p> <p>Embeddings are computed using a self-supervised SimSiam model fine-tuned with contrastive learning and can be generated from either:</p> <ul> <li>Instance segmentation masks, or</li> <li>Particle center coordinates (e.g. from particle identification or external pickers)</li> </ul> <p>Supported pipelines: - <code>Instance Segmentation \u2192 Subtomogram Embeddings \u2192 Visualization \u2192 (Optional Clustering)</code> - <code>Provided center coordinates (example Particle Identification) \u2192 Subtomogram Embeddings \u2192 Visualization \u2192 (Optional Clustering)</code></p>"},{"location":"subtomogram_embeddings/#overview","title":"Overview","text":"<p>For each detected instance, CryoSiam extracts a local 3D subtomogram and maps it into a high-dimensional embedding space.</p> <p>Quick guide</p> <ul> <li>You have instance masks \u2192 use instance-based embeddings</li> <li>You only have particle coordinates \u2192 use center-based embeddings</li> </ul>"},{"location":"subtomogram_embeddings/#input-modes-for-subtomogram-extraction","title":"Input modes for subtomogram extraction","text":"<p>CryoSiam supports two alternative input modes.</p>"},{"location":"subtomogram_embeddings/#1-instance-based-embeddings","title":"1. Instance-based embeddings","text":"<p>Subtomograms are extracted from instance segmentation masks.</p> <p>Required input</p> <ul> <li>instances_mask_folder</li> </ul> <p>Characteristics</p> <ul> <li>Object shapes define subtomogram regions</li> <li>Supports masking strategies (masking_type)</li> <li>Recommended when instance segmentation is available</li> </ul>"},{"location":"subtomogram_embeddings/#2-center-based-embeddings","title":"2. Center-based embeddings","text":"<p>Subtomograms are extracted as fixed-size cubes centered on particle coordinates.</p> <p>This mode is intended for:</p> <ul> <li>Particle Identification outputs</li> <li>External particle pickers</li> <li>Manually curated coordinates</li> </ul> <p>Required input</p> <ul> <li>centers_file</li> <li>centers_patch_size</li> </ul> <p>Instance segmentation is not required in this mode.</p> <p>Important constraint</p> <p>When using center-based embeddings: - <code>centers_patch_size</code> should be close to the expected physical size of the particle.     &gt; Overly large patches include excessive background signal and significantly degrade embedding quality.</p>"},{"location":"subtomogram_embeddings/#embedding-models-and-masking-strategies","title":"Embedding models and masking strategies","text":"<p>CryoSiam provides three embedding variants, controlled by the <code>masking_type</code> parameter (when working with masks provided from instance segmentation). Each variant corresponds to a different strategy for masking background signal when extracting subtomograms:</p> Masking type Description When to use <code>0</code> No masking \u2013 the raw subtomogram is extracted without applying an instance mask Use when instance masks are unreliable or when full surrounding context is desired <code>1</code> Convex hull masking \u2013 the instance mask is expanded to its convex hull Recommended default; balances object focus with local context <code>2</code> Strict masking \u2013 only voxels inside the instance mask are retained Use when isolating object shape and internal structure is critical <p>Each masking strategy corresponds to a separately trained embedding model. Make sure that the selected <code>masking_type</code> matches the trained model specified by <code>trained_model</code>.</p> <p>Note: For center-based embeddings, only <code>masking_type: 0</code> (no masking) is supported. Masking types <code>1</code> and <code>2</code> require instance masks and are incompatible with center-based extraction.</p> <p>Recommendation: Use <code>masking_type: 1</code> (convex hull masking) for most datasets, as it avoids errors with strict instance masking while suppressing background noise.</p>"},{"location":"subtomogram_embeddings/#example-results","title":"Example Results","text":"<ul> <li>UMAP visualization: each point represents a subtomogram embedding</li> <li>KMeans clustering: coarse grouping of similar structures</li> <li>Spectral clustering: captures fine-grained structural variability</li> </ul>"},{"location":"subtomogram_embeddings/#embedding-space-projection-umap","title":"Embedding space projection (UMAP)","text":""},{"location":"subtomogram_embeddings/#kmeans-clustering","title":"KMeans clustering","text":""},{"location":"subtomogram_embeddings/#spectral-clustering","title":"Spectral clustering","text":""},{"location":"subtomogram_embeddings/#trained-model","title":"Trained Model","text":"<p>Pre-trained embedding models are available for the different masking strategies.</p> <p>Example model (convex hull masking): CryoSiam subtomogram embedding convex-hull model (v1.0)</p> <p>Example model for centers (no masking): CryoSiam subtomogram embedding no masking model (v1.0)</p> <p>A list of all the provided models is available here: Trained models</p>"},{"location":"subtomogram_embeddings/#running-subtomogram-embeddings","title":"Running subtomogram embeddings","text":""},{"location":"subtomogram_embeddings/#generate-embeddings-from-instance-masks","title":"Generate embeddings from instance masks","text":"<pre><code>cryosiam simsiam_embeddings_predict --config_file=configs/subtomo_embeddings.yaml\n</code></pre> <p>To process a single tomogram only:</p> <pre><code>cryosiam simsiam_embeddings_predict --config_file=configs/subtomo_embeddings.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"subtomogram_embeddings/#generate-embeddings-from-particle-centers","title":"Generate embeddings from particle centers","text":"<pre><code>cryosiam simsiam_embeddings_from_centers_predict --config_file configs/subtomo_embeddings.yaml\n</code></pre> <p>To process a single tomogram only:</p> <pre><code>cryosiam simsiam_embeddings_from_centers_predict --config_file=configs/subtomo_embeddings.yaml --filename TS_01.mrc\n</code></pre> <p>This command:</p> <ul> <li>Reads particle centers from a .star or .csv file</li> <li>Extracts fixed-size subtomograms around each center</li> <li>Computes embeddings using the selected SimSiam model</li> </ul>"},{"location":"subtomogram_embeddings/#particle-centers-file-format","title":"Particle centers file format","text":"<p>When using center-based embeddings, particle coordinates must be provided in a .star or .csv file.</p> <p>Mandatory fields</p> Field name STAR equivalent Description tomo rlnMicrographName Tomogram name or path centroid-0 rlnCoordinateZ Z coordinate (voxel) centroid-1 rlnCoordinateY Y coordinate (voxel) centroid-2 rlnCoordinateX X coordinate (voxel) <ul> <li>One row per particle</li> <li>Coordinates must be in voxel space</li> <li>All tomograms to be processed must be listed in the same file</li> <li>Additional columns are allowed and ignored</li> </ul>"},{"location":"subtomogram_embeddings/#visualize-embeddings","title":"Visualize Embeddings","text":"<pre><code>cryosiam simsiam_visualize_embeddings --config_file=configs/subtomo_embeddings.yaml\n</code></pre> <p>This command generates PCA/UMAP projections and distance maps for qualitative inspection.</p>"},{"location":"subtomogram_embeddings/#optional-cluster-embeddings","title":"(Optional) Cluster embeddings","text":"<p>KMeans clustering:</p> <pre><code>cryosiam simsiam_embeddings_kmeans_clustering --config_file=configs/subtomo_embeddings.yaml\n</code></pre> <p>Spectral clustering:</p> <pre><code>cryosiam simsiam_embeddings_spectral_clustering --config_file=configs/subtomo_embeddings.yaml\n</code></pre>"},{"location":"subtomogram_embeddings/#example-configuration-configsconfig_subtomo_embeddingsyaml","title":"Example Configuration (<code>configs/config_subtomo_embeddings.yaml</code>)","text":"<p> Download example config</p> <pre><code>data_folder: '/scratch/stojanov/dataset1/predictions/denoised'\ninstances_mask_folder: '/scratch/stojanov/dataset1/predictions/instances'\ncenters_file: '/scratch/stojanov/dataset1/ribosome_centers.star'\ncenters_patch_size: 32\nprediction_folder: '/scratch/stojanov/dataset1/predictions/subtomo_embeds'\ntrained_model: '/g/zaugg/stojanov/simulated_datasets/final_models/simsiam_contrastive/version_1/model/last.ckpt'\ncontrastive: True\nfile_extension: '.mrc'\n\ntest_files: null\nclustering_files: null\nvisualization_files: null\n\nmin_particle_size: 10\nmax_particle_size: null\nmasking_type: 1\nexpand_labels: 3\n\nclustering_kmeans:\n  num_clusters: 6\n  visualization: True\n\nclustering_spectral:\n  num_clusters: 6\n  estimate_num_clusters: False\n  visualization: True\n\nvisualization:\n  prediction_folder: '/scratch/stojanov/dataset1/predictions/subtomo_embeds/vis'\n  distance: 'euclidean'\n  pca_components: null\n  visualization_suffix: 'instance_regions.csv'\n  visualize_umap: True\n  3d_umap: False\n\nparameters:\n  data:\n    patch_size: [ 64, 64, 64 ]\n    patch_overlap: null\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    spatial_dims: 3\n    in_channels: 1\n    dim: 1024\n\nhyper_parameters:\n  batch_size: 10\n</code></pre>"},{"location":"subtomogram_embeddings/#config-reference","title":"Config Reference","text":""},{"location":"subtomogram_embeddings/#toplevel-keys","title":"Top\u2011level keys","text":"Key Type Must change the default value Description <code>data_folder</code> <code>str</code> \u2705 Path to denoised tomograms <code>instances_mask_folder</code> <code>str</code> \u2705 Path to instance segmentation masks; <code>null</code> when working with centers <code>centers_file</code> <code>str</code> \u2705 Path to particle centers file; <code>null</code> when working with instance masks <code>centers_patch_size</code> <code>int</code> \u2705 Patch size around particle centers; <code>null</code> when working with instance masks <code>prediction_folder</code> <code>str</code> \u2705 Output directory for embeddings <code>trained_model</code> <code>str</code> \u2705 SimSiam embedding model checkpoint (<code>.ckpt</code>) <code>contrastive</code> <code>bool</code> \u274c Indicates contrastive (SimSiam) training <code>file_extension</code> <code>str</code> \u274c Input file extension (<code>.mrc</code> or <code>.rec</code>, default: <code>.mrc</code>) <code>test_files</code> <code>list[str]</code> or <code>null</code> \u274c Specific tomograms to process; <code>null</code> processes all files <code>min_particle_size</code> <code>int</code> \u2705 Minimum voxel size of valid instances <code>max_particle_size</code> <code>int</code> or <code>null</code> \u274c Maximum voxel size (optional); <code>null</code> = no limit. <code>masking_type</code> <code>int</code> \u274c Mask generation method (0 = no masking, 1 = convex hull masking, 2 - strict masking) <code>expand_labels</code> <code>int</code> \u274c Number of voxels to expand around mask boundaries for convex hull or strict masking"},{"location":"subtomogram_embeddings/#clustering_kmeans","title":"<code>clustering_kmeans</code>","text":"Key Type Must change the default value Description <code>num_clusters</code> <code>int</code> \u2705 Number of clusters for KMeans algorithm <code>visualization</code> <code>bool</code> \u274c If <code>true</code>, generate scatter/UMAP plots of the embeddings"},{"location":"subtomogram_embeddings/#clustering_spectral","title":"<code>clustering_spectral</code>","text":"Key Type Must change the default value Description <code>num_clusters</code> <code>int</code> \u2705 Expected number of spectral clusters <code>estimate_num_clusters</code> <code>bool</code> \u274c If <code>true</code>, automatically estimate cluster number <code>visualization</code> <code>bool</code> \u274c Enable cluster visualizations"},{"location":"subtomogram_embeddings/#visualization","title":"<code>visualization</code>","text":"Key Type Must change the default value Description <code>prediction_folder</code> <code>str</code> \u2705 Directory for saving visualizations and projections. <code>distance</code> <code>str</code> \u274c Metric for pairwise similarity (<code>euclidean</code>, <code>cosine</code>, etc.). <code>pca_components</code> <code>int</code> or <code>null</code> \u274c Number of PCA components before projection. <code>visualization_suffix</code> <code>str</code> \u274c CSV file containing mapping between IDs and embedding vectors. <code>visualize_umap</code> <code>bool</code> \u274c Run 2D UMAP projection for visualization. <code>3d_umap</code> <code>bool</code> \u274c Run 3D UMAP visualization (interactive)."},{"location":"subtomogram_embeddings/#parameters","title":"<code>parameters</code>","text":"Key Type Must change the default value Description <code>data.patch_size</code> <code>list[int]</code> \u274c Sliding-window patch size for 3D inference <code>data.min</code> <code>float</code> \u274c Intensity minimum value for data scaling <code>data.max</code> <code>float</code> \u274c Intensity maximum value for data scaling <code>data.mean</code> <code>float</code> \u274c Mean used for normalization <code>data.std</code> <code>float</code> \u274c Std used for normalization <code>network.in_channels</code> <code>int</code> \u274c Number of input channels (usually <code>1</code>) <code>network.spatial_dims</code> <code>int</code> \u274c Dimensionality of the model (<code>3</code> for tomograms) <code>network.dim</code> <code>int</code> \u274c Dimension of embedding space (e.g., <code>1024</code>)."},{"location":"subtomogram_embeddings/#hyper_parameters","title":"<code>hyper_parameters</code>","text":"Key Type Must change the default value Description <code>batch_size</code> <code>int</code> \u274c Number of subtomograms per batch (default <code>10</code>)"},{"location":"subtomogram_embeddings/#troubleshooting","title":"Troubleshooting","text":"Symptom Suggested Fix Empty embedding CSV Check instance masks and <code>instances_mask_folder</code> Few embeddings Lower <code>min_particle_size</code> GPU memory error Reduce <code>batch_size</code> Clusters overlap visually Increase <code>num_clusters</code> or use spectral clustering Embeddings dominated by background Reduce <code>centers_patch_size</code>"},{"location":"subtomogram_embeddings/#next-steps","title":"Next Steps","text":"<ul> <li>Instance segmentation</li> <li>Visualization</li> <li>Usage overview</li> </ul>"},{"location":"trained_models/","title":"Trained models","text":""},{"location":"trained_models/#trained-models","title":"Trained Models","text":"<p>CryoSiam is distributed with a collection of pretrained models that enable out-of-the-box denoising, segmentation, particle identification, and subtomogram embedding generation for cryo-electron tomography (cryo-ET) data.</p> <p>All pretrained models are hosted on Hugging Face and can be downloaded individually as <code>.ckpt</code> files. Using pretrained weights is strongly recommended for inference and for fine-tuning on new datasets, as it significantly reduces training time and improves convergence.</p> <p>Model repository: All models listed below are available at https://huggingface.co/frosinastojanovska/cryosiam_v1.0</p>"},{"location":"trained_models/#overview-of-available-models","title":"Overview of available models","text":"Model file Task Used in module Description cryosiam_denoising.ckpt Denoising Denoising Self-supervised denoising model trained on simulated WBP tomograms to reduce noise while preserving structural details. cryosiam_lamella.ckpt Lamella prediction Semantic segmentation Binary segmentation model for identifying lamella regions and suppressing false positives outside the lamella. cryosiam_semantic_segmentation.ckpt Semantic segmentation Semantic segmentation Multi-class voxel-wise semantic segmentation of biological structures in denoised tomograms. cryosiam_ribosome_segmentation.ckpt Semantic segmentation Semantic segmentation Specialized semantic model trained for ribosome segmentation. cryosiam_semantic_myco_candidates.ckpt Particle identification Particle identification Semantic model trained to predict candidate macromolecular complexes for particle picking. cryosiam_instance.ckpt Instance segmentation Instance segmentation Instance segmentation model for separating individual macromolecular complexes. cryosiam_instance_convex_hull.ckpt Instance segmentation Instance segmentation Variant of the instance model using convex-hull\u2013based instance representations. dense_simsiam_pretrained.ckpt Self-supervised pretraining Semantic training Dense SimSiam backbone pretrained for initializing semantic segmentation training. simsiam_embeds_denoised_convex_hull.ckpt Subtomogram embeddings Subtomogram embeddings Embedding model using convex-hull masking (<code>masking_type: 1</code>), recommended default for instance-based embeddings. simsiam_embeds_denoised_no_masking.ckpt Subtomogram embeddings Subtomogram embeddings Embedding model without masking (<code>masking_type: 0</code>), required for center-based embeddings. simsiam_embeds_denoised_strict.ckpt Subtomogram embeddings Subtomogram embeddings Embedding model with strict instance masking (<code>masking_type: 2</code>) for isolating internal object structure."},{"location":"trained_models/#choosing-the-right-model","title":"Choosing the right model","text":""},{"location":"trained_models/#denoising","title":"Denoising","text":"<p>Use <code>cryosiam_denoising.ckpt</code> to preprocess raw WBP tomograms before any downstream task.</p>"},{"location":"trained_models/#semantic-segmentation","title":"Semantic segmentation","text":"<ul> <li>Use <code>cryosiam_semantic_segmentation.ckpt</code> for general multi-class segmentation.</li> <li>Use <code>cryosiam_ribosome_segmentation.ckpt</code> for ribosome-focused workflows.</li> <li>Always combine with <code>cryosiam_lamella.ckpt</code> for lamella masking when available.</li> </ul>"},{"location":"trained_models/#particle-identification","title":"Particle identification","text":"<p>Use <code>cryosiam_semantic_myco_candidates.ckpt</code> to predict candidate regions and extract particle centers.</p>"},{"location":"trained_models/#instance-segmentation","title":"Instance segmentation","text":"<p>Use <code>cryosiam_instance.ckpt</code> for general instance segmentation. The convex hull variant can be used for alternative instance representations.</p>"},{"location":"trained_models/#subtomogram-embeddings","title":"Subtomogram embeddings","text":"<p>Select the embedding model based on the masking strategy:</p> <ul> <li><code>masking_type: 0</code> \u2192 <code>simsiam_embeds_denoised_no_masking.ckpt</code> (required for center-based embeddings)</li> <li><code>masking_type: 1</code> \u2192 <code>simsiam_embeds_denoised_convex_hull.ckpt</code> (recommended default)</li> <li><code>masking_type: 2</code> \u2192 <code>simsiam_embeds_denoised_strict.ckpt</code></li> </ul> <p>Important: When using <code>simsiam_embeddings_from_centers_predict</code>, you must use the no-masking embedding model and provide a patch size close to the expected particle size to avoid embedding background signal.</p>"},{"location":"trained_models/#using-pretrained-models","title":"Using pretrained models","text":"<p>After downloading a model checkpoint, reference it in your configuration file:</p> <pre><code>trained_model: /path/to/model.ckpt\n</code></pre> <p>CryoSiam will automatically load the weights and configure the network accordingly.</p>"},{"location":"trained_models/#fine-tuning-and-reproducibility","title":"Fine-tuning and reproducibility","text":"<ul> <li>All models can be fine-tuned on custom datasets using the semantic segmentation training pipeline.</li> <li>For reproducibility, record:<ul> <li>model filename</li> <li>CryoSiam version</li> <li>configuration file used for inference or training</li> </ul> </li> </ul>"},{"location":"trained_models/#citation","title":"Citation","text":"<p>If you use CryoSiam pretrained models in your work, please cite:</p> <p>Stojanovska et al. CryoSiam: self-supervised representation learning for automated cryo-ET analysis bioRxiv (2025)</p>"},{"location":"trained_models/#contributing-trained-models","title":"Contributing trained models","text":"<p>If you have trained your own semantic segmentation model using CryoSiam and would like to make it available to the community, you are very welcome to contribute it.</p> <p>Please contact Frosina Stojanovska with: - a short description of the model (task, classes, data type), - the CryoSiam version used, - and a link to the trained checkpoint.</p> <p>After review, the model can be added to the official Hugging Face repository and listed on this page.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial-endtoend-cryosiam-on-cryoet-data-portal-ts_02-dataset-10003","title":"Tutorial: End\u2011to\u2011End CryoSiam on CryoET Data Portal \u2013 TS_02 (Dataset 10003)","text":"<p>This walkthrough shows how to run the full CryoSiam pipeline on TS_02 from the CryoET Data Portal dataset **10003 ** (Mycoplasma pneumoniae with chloramphenicol). We\u2019ll go from raw tomogram to:</p> <ul> <li>denoised tomogram</li> <li>lamella prediction</li> <li>semantic segmentation</li> <li>instance segmentation</li> <li>subtomogram embeddings</li> <li>particle identification</li> </ul> <p>Why TS_02? This tomogram was used to generate the examples in the figures from the CryoSiam preprint.</p>"},{"location":"tutorial/#data-source","title":"Data source","text":"<ul> <li>Dataset page: CryoET Data Portal \u2013 Mycoplasma pneumoniae treated with chloramphenicol, Deposition 10003<ul> <li>Runs include TS_02 reconstructed tomogram.</li> </ul> </li> <li>You can browse and download via the portal UI,   the Python API client.</li> </ul>"},{"location":"tutorial/#trained-models","title":"Trained Models","text":"<p>The available trained models and where to download them are described here: Trained models.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<p>We assume you already installed CryoSiam as shown in the docs, as well as CryoSiam-Vis shown in docs.</p> <p>Folder layout we\u2019ll use (adjust the root path /scratch/ to your setup):</p> <pre><code>/scratch/cryosiam_tutorial/\n\u251c\u2500\u2500 data/                    # raw or denoised tomograms\n\u251c\u2500\u2500 models/                  # pretrained models of CryoSiam\n\u251c\u2500\u2500 preds/                   # prediction folders\n\u2502   \u251c\u2500\u2500 denoised/\n\u2502   \u251c\u2500\u2500 lamella/\n\u2502   \u251c\u2500\u2500 semantic/\n\u2502   \u2514\u2500\u2500 instance/\n\u2514\u2500\u2500 configs/                 # config files\n</code></pre>"},{"location":"tutorial/#step-0-download-ts_02","title":"Step 0 - Download TS_02","text":""},{"location":"tutorial/#option-a-portal-ui","title":"Option A: Portal UI","text":"<ol> <li>Open the dataset page, search for TS_02, click View Tomogram, and download the tomogram volume.</li> <li>Save as: <code>/scratch/cryosiam_tutorial/data/TS_02.mrc</code>.</li> </ol>"},{"location":"tutorial/#option-b-python-api-client","title":"Option B: Python API client","text":"<p>First, install the python cryoet_data_portal package:</p> <pre><code>pip install cryoet_data_portal\n</code></pre> <p>Then download tomogram TS_02:</p> <pre><code>from cryoet_data_portal import Client, Tomogram\n\nclient = Client()\n\ntomogram = Tomogram.get_by_id(client, 632)\ntomogram.download_mrcfile()\n</code></pre>"},{"location":"tutorial/#step-1-denoising","title":"Step 1 - Denoising","text":"<p>Download the model from here.</p> <p>Create <code>configs/config_denoising.yaml</code> (download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/data'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/denoised'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_denoising.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_raw_predictions: False\nscale_prediction: True\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n\nhyper_parameters:\n  batch_size: 3\n</code></pre> <p>Run:</p> <pre><code>cd /scratch/cryosiam_tutorial\nconda activate cryosiam\ncryosiam denoise_predict --config_file=configs/config_denoising.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_denoising --config_file=configs/config_denoising.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#step-2-lamella-prediction","title":"Step 2 - Lamella Prediction","text":"<p>Download the model from here.</p> <p>Create <code>configs/config_lamella.yaml</code> (download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/lamella'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_lamella.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_internal_files: False\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold: 0.9\n    postprocessing: True\n    3d_postprocessing: False\n\nhyper_parameters:\n  batch_size: 2\n</code></pre> <p>Run:</p> <pre><code>conda activate cryosiam\ncryosiam semantic_predict --config_file=configs/config_lamella.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_semantic --config_file=configs/config_lamella.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#step-3-semantic-segmentation-classes","title":"Step 3 - Semantic Segmentation (classes)","text":"<p>Download the model from here.</p> <p>Create <code>configs/config_semantic.yaml</code> download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\nmask_folder: '/scratch/cryosiam_tutorial/preds/lamella'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/semantic'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_semantic_segmentation.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold: 0.1\n    postprocessing_sizes: [ -1, 5000, -1, -1, -1 ]\n\nhyper_parameters:\n  batch_size: 2\n</code></pre> <p>Run:</p> <pre><code>conda activate cryosiam\ncryosiam semantic_predict --config_file=configs/config_semantic.yaml\ncryosiam semantic_postprocessing --config_file=configs/config_semantic.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_semantic --config_file=configs/config_semantic.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#step-4-instance-segmentation-objects","title":"Step 4 - Instance Segmentation (objects)","text":"<p>Download the model from here.</p> <p>Create <code>configs/config_instance.yaml</code> download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\nmask_folder: '/scratch/cryosiam_tutorial/preds/lamella'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/instance'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_instance.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nsave_raw_predictions: False\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold_foreground: 0.65\n    boundary_bias: 0.8\n    min_center_distance: 1\n    max_center_distance: 4\n    distance_type: 1   # 0 for using only predicted distances, 1 for using predicted distances + cdist from foreground, 2 for using only cdist\n    postprocessing: True\n\nhyper_parameters:\n  batch_size: 3\n</code></pre> <p>Run:</p> <pre><code>conda activate cryosiam\ncryosiam instance_predict --config_file=configs/config_instance.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_instance --config_file=configs/config_instance.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#step-5-filter-and-visualize-instances-within-a-mask-membrane-proteins","title":"Step 5 - Filter and visualize instances within a mask (membrane proteins)","text":"<p>This step takes the predicted mask for the membrane and isolates the subset of instance objects that spatially overlap with the selected semantic mask. </p> <p>Take the config file from the previous step, and add the fields <code>filtering_mask_folder</code>, <code>filtering_mask_expand_voxels</code> and <code>filtering_mask_expand_labels</code>. There is also support to use a mask provided as a mrc format file, and the field <code>filtering_mask_folder: '.mrc'</code> can be added to the config file to use that type of a mask. </p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\nmask_folder: '/scratch/cryosiam_tutorial/preds/lamella'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/instance'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_instance.ckpt'\nfile_extension: '.mrc'\n\n\nfiltering_mask_folder: '/scratch/cryosiam_tutorial/preds/semantic'\nfiltering_mask_expand_voxels: 2\nfiltering_mask_labels: [1]\nfiltering_mask_extension: '.h5' # it can be .h5 for a mask coming from CryoSiam prediction or .mrc/.rec for any mask in mrc format\n\ntest_files: null\n\nsave_raw_predictions: False\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    threshold_foreground: 0.65\n    boundary_bias: 0.8\n    min_center_distance: 1\n    max_center_distance: 4\n    distance_type: 1   # 0 for using only predicted distances, 1 for using predicted distances + cdist from foreground, 2 for using only cdist\n    postprocessing: True\n\nhyper_parameters:\n  batch_size: 10\n</code></pre> <p>Run:</p> <pre><code>conda activate cryosiam\ncryosiam instance_filter --config_file=configs/config_instance.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_filtered_instance --config_file=configs/config_instance.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p> </p>"},{"location":"tutorial/#step-6-subtomogram-embeddings","title":"Step 6 - Subtomogram Embeddings","text":"<p>Download the model from here.</p> <p>This example uses the convex hull masking model (<code>masking_type: 1</code>), which requires instance segmentation masks.</p> <p>Create <code>configs/config_subtomo_embeddings.yaml</code> download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\ninstances_mask_folder: '/scratch/cryosiam_tutorial/preds/instance'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/subtomo_embeds'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/simsiam_embeds_denoised_convex_hull.ckpt'\ncontrastive: True\nfile_extension: '.mrc'\n\ntest_files: null\nclustering_files: null\nvisualization_files: null\n\nmin_particle_size: 1000  # create embeddings only to instances this much min voxels in their mask\nmax_particle_size: null\nmasking_type: 1\nexpand_labels: 3\n\nclustering_kmeans:\n  num_clusters: 6\n  visualization: True\n\nclustering_spectral:\n  num_clusters: 6\n  estimate_num_clusters: False\n  visualization: True\n\nvisualization:\n  prediction_folder: '/scratch/cryosiam_tutorial/preds/subtomo_embeds/vis'\n  distance: 'euclidean'\n  pca_components: null\n  visualization_suffix: 'instance_regions.csv'\n  visualize_umap: True\n  3d_umap: False\n\nparameters:\n  data:\n    patch_size: [ 64, 64, 64 ]\n    patch_overlap: null\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    spatial_dims: 3\n    in_channels: 1\n    dim: 1024\n\nhyper_parameters:\n  batch_size: 10\n</code></pre> <p>Run:</p> <pre><code># Generate embeddings (TS_02 only)\ncryosiam simsiam_embeddings_predict --config_file=configs/config_subtomo_embeddings.yaml --filename TS_02.mrc\n\n# Visualize (UMAP/PCA)\ncryosiam simsiam_visualize_embeddings --config_file=configs/config_subtomo_embeddings.yaml\n\n# Optional clustering\ncryosiam simsiam_embeddings_kmeans_clustering --config_file=configs/config_subtomo_embeddings.yaml\ncryosiam simsiam_embeddings_spectral_clustering --config_file=configs/config_subtomo_embeddings.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_embeddings --config_file=configs/config_subtomo_embeddings.yaml\n</code></pre> <p>Output:</p> <p></p> <p>Visualize clusters with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_embeddings_clusters --config_file=configs/config_subtomo_embeddings.yaml --clustering=spectral\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#step-7-particle-identification","title":"Step 7 - Particle identification","text":"<p>Download the model from here.</p> <p>Create <code>configs/config_semantic_particle.yaml</code> download and adapt from the general example):</p> <pre><code>data_folder: '/scratch/cryosiam_tutorial/preds/denoised'\nmask_folder: '/scratch/cryosiam_tutorial/preds/lamella'\nprediction_folder: '/scratch/cryosiam_tutorial/preds/semantic_particle'\n\ntrained_model: '/scratch/cryosiam_tutorial/models/cryosiam_semantic_myco_candidates.ckpt'\nfile_extension: '.mrc'\n\ntest_files: null\n\nparameters:\n  data:\n    patch_size: [ 128, 128, 128 ]\n    min: 0\n    max: 1\n    mean: 0\n    std: 1\n  network:\n    in_channels: 1\n    spatial_dims: 3\n    out_channels: 14\n    threshold: 0.7\n\nhyper_parameters:\n  batch_size: 2\n</code></pre> <p>Run:</p> <pre><code>conda activate cryosiam\ncryosiam semantic_predict --config_file=configs/config_semantic_particle.yaml\ncryosiam semantic_to_centers --config_file=configs/config_semantic_particle.yaml\n</code></pre> <p>Visualize with:</p> <pre><code>conda activate cryosiam_vis\ncryosiam_vis visualize_semantic --config_file=configs/config_semantic_particle.yaml  --filename TS_02.mrc\n</code></pre> <p>Output:</p> <p></p>"},{"location":"tutorial/#troubleshooting","title":"Troubleshooting","text":"Symptom Fix TS_02 missing or different extension Check the downloaded filename and set <code>file_extension</code> accordingly. GPU OOM Reduce <code>batch_size</code> in the configs."},{"location":"tutorial/#notes","title":"Notes","text":"<ul> <li>CryoSiam models are trained primarily on lamella regions; always gate with the lamella mask to avoid false   positives outside the lamella.</li> </ul>"},{"location":"usage/","title":"Overview and workflows","text":""},{"location":"usage/#workflows","title":"Workflows","text":"<p>CryoSiam workflows are modular pipelines designed to process cryo-electron tomography (cryo-ET) data step by step. Each workflow consists of one or more modules, each addressing a specific task such as denoising or segmentation.</p> <p>You can use individual modules independently or combine them into complete analysis pipelines depending on your scientific question.</p> <p>For methodological details, please refer to the CryoSiam preprint.</p>"},{"location":"usage/#how-to-choose-a-workflow","title":"How to choose a workflow","text":"<p>If you are new to CryoSiam, consider the following guidelines:</p> <ul> <li>Use Workflow 1 for general denoising and semantic segmentation (or particle identification) of   tomograms</li> <li>Use Workflow 1b to train a new semantic segmentation model</li> <li>Use Workflow 2 when individual instances of structures need to be separated</li> <li>Use Workflow 3 for downstream analysis of subtomograms such as clustering or similarity comparisons</li> </ul>"},{"location":"usage/#workflow-1","title":"Workflow 1","text":""},{"location":"usage/#denoising-semantic-segmentation-particle-identification","title":"Denoising \u2192 Semantic Segmentation / Particle Identification","text":"<p>This workflow is suitable for interpreting cellular context or detecting specific structures in cryo-ET data.</p> <ol> <li> <p>Denoising    Reduce noise in the raw tomogram while preserving structural features.</p> </li> <li> <p>Semantic Segmentation    Assign each voxel to a biological class (e.g., membranes, filaments, complexes).</p> </li> </ol> <p>Alternative: Particle Identification can be used directly after denoising to locate specific particles of interest.</p> <p>See detailed documentation:</p> <ul> <li>Denoising</li> <li>Semantic Segmentation</li> <li>Particle Identification</li> </ul>"},{"location":"usage/#workflow-1b","title":"Workflow 1b","text":""},{"location":"usage/#denoising-semantic-segmentation-training","title":"Denoising \u2192 Semantic Segmentation (Training)","text":"<p>This workflow is used to train a semantic segmentation model on cryo-ET data using CryoSiam\u2019s self-supervised pretrained weights and user-provided ground truth data.</p> <p>It is intended for users who want to adapt CryoSiam to new datasets or biological contexts.</p> <ol> <li> <p>Denoising    Preprocess raw tomograms to improve signal quality.</p> </li> <li> <p>Semantic Segmentation (Training)    Train (fine-tune) a semantic segmentation model using the self-supervised trained weights as starting point.</p> </li> </ol> <p>After training, the resulting model can be used for inference as described in Workflow 1.</p> <p>See detailed documentation:</p> <ul> <li>Denoising</li> <li>Semantic Segmentation \u2013 Training</li> </ul>"},{"location":"usage/#workflow-2","title":"Workflow 2","text":""},{"location":"usage/#denoising-instance-segmentation","title":"Denoising \u2192 Instance Segmentation","text":"<p>This workflow focuses on separating individual particles.</p> <ol> <li> <p>Denoising    Improve signal quality for reliable downstream processing.</p> </li> <li> <p>Instance Segmentation    Identify and separate individual instances of particles.</p> </li> </ol> <p>See detailed documentation:</p> <ul> <li>Denoising</li> <li>Instance Segmentation</li> </ul>"},{"location":"usage/#workflow-3","title":"Workflow 3","text":""},{"location":"usage/#denoising-optional-instance-segmentation-subtomogram-embeddings","title":"Denoising \u2192 (Optional) Instance Segmentation \u2192 Subtomogram Embeddings","text":"<p>This workflow enables quantitative downstream analysis of extracted subtomograms.</p> <ol> <li> <p>Denoising    Preprocess tomograms for improved structural information.</p> </li> <li> <p>Instance Segmentation (optional)    Detect and separate candidate particles.</p> </li> </ol> <p>Alternative:    Instance segmentation can be skipped if particle centers are provided;    see  Subtomogram Embeddings for details.</p> <ol> <li>Subtomogram Embeddings    Represent particle subtomograms as feature vectors for clustering, comparison, or further analysis.</li> </ol> <p>See detailed documentation:</p> <ul> <li>Denoising</li> <li>Instance Segmentation</li> <li>Subtomogram Embeddings</li> </ul>"},{"location":"usage/#trained-models","title":"Trained Models","text":"<p>Pre-trained models available for CryoSiam workflows are described here:</p> <ul> <li>Trained Models</li> </ul>"},{"location":"usage/#running-a-workflow","title":"Running a workflow","text":"<p>Each CryoSiam module is configured using a YAML configuration file that defines inputs, outputs, and model parameters.</p> <p>To run a module, use:</p> <pre><code>cryosiam &lt;module name&gt; --config_file configs/&lt;module&gt;.yaml\n</code></pre> <p>Detailed explanations of configuration options are provided on the documentation page of each module.</p>"},{"location":"usage/#running-cryosiam-at-scale-slurm-hpc","title":"Running CryoSiam at Scale (Slurm / HPC)","text":"<p>CryoSiam prediction commands run on one GPU per process. To efficiently process large datasets on HPC systems, predictions should be parallelized across tomograms using Slurm job submission.</p> <p>Instead of processing all tomograms in a single command, CryoSiam allows processing one tomogram per job via the <code>--filename</code> argument.</p> <p>This enables:</p> <ul> <li>Full utilization of multi-GPU clusters</li> <li>Independent job retries</li> <li>Clean scaling to hundreds of tomograms</li> </ul> <p>For more details see: Scaling to large datasets on HPC</p>"},{"location":"visualization/","title":"Visualization","text":""},{"location":"visualization/#visualization-cryosiamvis","title":"Visualization (CryoSiam\u2011Vis)","text":"<p>The cryosiam-vis package provides interactive visualization utilities (via napari and dash) for inspecting results produced by CryoSiam:</p> <ul> <li>Denoised tomograms</li> <li>Semantic segmentation results</li> <li>Instance segmentation results (including filtered instances)</li> <li>Particle/coordinate sets from .star or .csv files</li> <li>Subtomogram embedding spaces (UMAP / clustering)</li> </ul> <p>Most visualization commands open an interactive napari viewer, while embedding exploration uses a lightweight dash interface.</p>"},{"location":"visualization/#install","title":"Install","text":"<p>Refer to the CryoSiam\u2011Vis installation guide.</p>"},{"location":"visualization/#command-overview","title":"Command overview","text":"<p>All visualizations are accessed through a single CLI with subcommands:</p> <pre><code>cryosiam_vis --version\ncryosiam_vis &lt;subcommand&gt; [arguments]\n</code></pre> <p>Important: All visualization commands reuse the same configuration files used during CryoSiam inference. No separate visualization configuration is required.</p>"},{"location":"visualization/#available-subcommands","title":"Available subcommands","text":"<ul> <li><code>visualize_denoising</code> \u2013 visualize denoised vs raw tomograms</li> <li><code>visualize_semantic</code> \u2013 overlay semantic segmentation predictions</li> <li><code>visualize_instance</code> \u2013 visualize instance segmentation results</li> <li><code>visualize_filtered_instance</code> \u2013 visualize filtered instance segmentation results</li> <li><code>visualize_coordinates</code> \u2013 plot particle coordinates from <code>.star</code> / <code>.csv</code> files</li> <li><code>visualize_embeddings</code> \u2013 interactive embedding visualization</li> <li><code>visualize_embeddings_clusters</code> \u2013 embedding visualization with clustering labels</li> </ul>"},{"location":"visualization/#visualize_denoising","title":"<code>visualize_denoising</code>","text":"<p>Visualize the denoised tomogram produced by <code>cryosiam denoise_predict</code> and optionally compare it to the raw input.</p>"},{"location":"visualization/#usage","title":"Usage","text":"<pre><code>cryosiam_vis visualize_denoising --config_file configs/denoise.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"visualization/#arguments","title":"Arguments","text":"Argument Required Description <code>--config_file</code> \u2705 The same YAML used with <code>cryosiam denoise_predict</code>. <code>--filename</code> \u2705 Tomogram filename (including extension)."},{"location":"visualization/#what-it-loads","title":"What it loads","text":"<ul> <li>Raw tomogram from <code>data_folder</code></li> <li>Denoised tomogram from <code>prediction_folder</code></li> <li>Opens both as layers in napari for side\u2011by\u2011side inspection</li> </ul>"},{"location":"visualization/#visualize_semantic","title":"<code>visualize_semantic</code>","text":"<p>Overlay semantic segmentation predictions on the denoised tomogram.</p>"},{"location":"visualization/#usage_1","title":"Usage","text":"<pre><code>cryosiam_vis visualize_semantic --config_file configs/semantic.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"visualization/#arguments_1","title":"Arguments","text":"Argument Required Description <code>--config_file</code> \u2705 The same YAML used with <code>cryosiam semantic_predict</code>. <code>--filename</code> \u2705 Tomogram filename (including extension)."},{"location":"visualization/#what-it-loads_1","title":"What it loads","text":"<ul> <li>Denoised tomogram (<code>data_folder</code>)</li> <li>Semantic probabilities and/or segmentation masks (<code>prediction_folder</code>)</li> <li>Lamella mask (if <code>mask_folder</code> is defined)</li> </ul>"},{"location":"visualization/#visualize_instance","title":"<code>visualize_instance</code>","text":"<p>Visualize instance segmentation volumes and labels.</p>"},{"location":"visualization/#usage_2","title":"Usage","text":"<pre><code>cryosiam_vis visualize_instance --config_file configs/instance.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"visualization/#arguments_2","title":"Arguments","text":"Argument Required Description <code>--config_file</code> \u2705 The same YAML used with <code>cryosiam instance_predict</code>. <code>--filename</code> \u2705 Tomogram filename (including extension)."},{"location":"visualization/#what-it-loads_2","title":"What it loads","text":"<ul> <li>Denoised tomogram (<code>data_folder</code>)</li> <li>Instance segmentation masks from <code>prediction_folder</code></li> </ul>"},{"location":"visualization/#visualize_filtered_instance","title":"<code>visualize_filtered_instance</code>","text":"<p>Visualize filtered instance segmentation results produced by <code>cryosiam instance_filter</code>.</p>"},{"location":"visualization/#usage_3","title":"Usage","text":"<pre><code>cryosiam_vis visualize_filtered_instance --config_file configs/instance_filter.yaml --filename TS_01.mrc\n</code></pre>"},{"location":"visualization/#arguments_3","title":"Arguments","text":"Argument Required Description <code>--config_file</code> \u2705 The YAML used with <code>cryosiam instance_filter</code>. <code>--filename</code> \u2705 Tomogram filename (including extension)."},{"location":"visualization/#what-it-loads_3","title":"What it loads","text":"<ul> <li>Denoised tomogram</li> <li>Filtered instance masks</li> </ul>"},{"location":"visualization/#visualize_coordinates","title":"<code>visualize_coordinates</code>","text":"<p>Plot particle coordinates from a .star or .csv file onto a tomogram.</p>"},{"location":"visualization/#usage_4","title":"Usage","text":"<pre><code>cryosiam_vis visualize_coordinates --config_file configs/semantic_particle.yaml --filename TS_01.mrc --point_size 15\n</code></pre>"},{"location":"visualization/#arguments_4","title":"Arguments","text":"Argument Required Default Description <code>--config_file</code> \u2705 \u2013 Config file used for CryoSiam particle identification <code>--filename</code> \u2705 \u2013 Tomogram filename (including extension) <code>--point_size</code> \u274c <code>15</code> Marker size for plotted points"},{"location":"visualization/#notes","title":"Notes","text":"<ul> <li>Coordinates are read from the .star or .csv file specified in the configuration.</li> <li>Coordinates must be in voxel space and aligned with the tomogram.</li> </ul>"},{"location":"visualization/#visualize_embeddings","title":"<code>visualize_embeddings</code>","text":"<p>Open an interactive embedding viewer for exploratory analysis.</p>"},{"location":"visualization/#usage_5","title":"Usage","text":"<pre><code>cryosiam_vis visualize_embeddings --config_file configs/subtomo_embeddings.yaml\n</code></pre>"},{"location":"visualization/#what-it-does","title":"What it does","text":"<ul> <li>Loads embedding projections produced by the subtomogram embeddings module</li> <li>Opens an interactive dash interface for UMAP/PCA exploration</li> </ul>"},{"location":"visualization/#visualize_embeddings_clusters","title":"<code>visualize_embeddings_clusters</code>","text":"<p>Visualize embedding projections with cluster assignments.</p>"},{"location":"visualization/#usage_6","title":"Usage","text":"<pre><code>cryosiam_vis visualize_embeddings_clusters --config_file configs/subtomo_embeddings.yaml --clustering kmeans\n</code></pre>"},{"location":"visualization/#arguments_5","title":"Arguments","text":"Argument Required Description <code>--config_file</code> \u2705 Configuration file used for embedding generation/clustering <code>--clustering</code> \u2705 Clustering type: <code>kmeans</code> or <code>spectral</code>"},{"location":"visualization/#see-also","title":"See also","text":"<ul> <li>CryoSiam usage overview</li> </ul>"}]}